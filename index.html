<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Martin Dokholyan</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --nav-bg: #c0c0c0;
            --nav-border: #888;
            --link-color: #0000ee;
            --active-bg: #ffffff;
            --content-bg: #f8f8f8;
            --content-border: #000;
            --pixel-color: rgba(0,0,0,0.03);
            --pixel-dot: rgba(60,60,60,0.08);
        }

        body.dark-mode {
            --bg-color: #1a1a1a;
            --text-color: #c0c0c0;
            --nav-bg: #2d2d2d;
            --nav-border: #444;
            --link-color: #5dade2;
            --active-bg: #3d3d3d;
            --content-bg: #252525;
            --content-border: #444;
            --pixel-color: rgba(255,255,255,0.02);
            --pixel-dot: rgba(180,180,180,0.05);
        }

        body {
            font-family: "Courier New", monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 20px;
            transition: background-color 0.3s, color 0.3s;
        }

        nav {
            margin-bottom: 20px;
            background: var(--nav-bg);
            padding: 10px;
            border: 2px outset var(--nav-border);
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            flex-wrap: wrap;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .nav-links {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }

        nav a {
            color: var(--link-color);
            text-decoration: underline;
            margin: 0 10px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s, background-color 0.3s;
        }

        nav a {
            padding: 2px 6px;
        }

        nav a.active {
            background: var(--active-bg);
        }

        .dark-toggle {
            margin-left: 20px;
            padding: 4px 10px;
            font-family: "Courier New", monospace;
            font-size: 11px;
            cursor: pointer;
            background: #808080;
            border: 2px outset #999;
            color: #fff;
            transition: all 0.2s;
        }

        .dark-toggle:hover {
            background: #707070;
        }

        .dark-toggle:active {
            border-style: inset;
        }

        body.dark-mode .dark-toggle {
            background: #4a4a4a;
            border-color: #666;
            color: #ffd700;
        }

        body.dark-mode .dark-toggle:hover {
            background: #5a5a5a;
        }

        .style-toggle {
            margin-left: 8px;
            padding: 4px 10px;
            font-family: "Courier New", monospace;
            font-size: 11px;
            cursor: pointer;
            background: #808080;
            border: 2px outset #999;
            color: #fff;
            transition: all 0.2s;
        }

        .style-toggle:hover {
            background: #707070;
        }

        .style-toggle:active {
            border-style: inset;
        }

        body.dark-mode .style-toggle {
            background: #4a4a4a;
            border-color: #666;
            color: #fff;
        }

        /* ========== MODERN MODE (shadcn-inspired) ========== */
        body.modern-mode {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            padding: 0;
            --radius: 0;
            --background: 0 0% 100%;
            --foreground: 240 10% 3.9%;
            --card: 0 0% 100%;
            --card-foreground: 240 10% 3.9%;
            --primary: 240 5.9% 10%;
            --primary-foreground: 0 0% 98%;
            --secondary: 240 4.8% 95.9%;
            --secondary-foreground: 240 5.9% 10%;
            --muted: 240 4.8% 95.9%;
            --muted-foreground: 240 3.8% 46.1%;
            --accent: 240 4.8% 95.9%;
            --accent-foreground: 240 5.9% 10%;
            --border: 240 5.9% 90%;
            --ring: 240 5.9% 10%;
            background: hsl(var(--background));
            color: hsl(var(--foreground));
        }

        body.modern-mode.dark-mode {
            --background: 240 10% 3.9%;
            --foreground: 0 0% 98%;
            --card: 240 10% 3.9%;
            --card-foreground: 0 0% 98%;
            --primary: 0 0% 98%;
            --primary-foreground: 240 5.9% 10%;
            --secondary: 240 3.7% 15.9%;
            --secondary-foreground: 0 0% 98%;
            --muted: 240 3.7% 15.9%;
            --muted-foreground: 240 5% 64.9%;
            --accent: 240 3.7% 15.9%;
            --accent-foreground: 0 0% 98%;
            --border: 240 3.7% 15.9%;
            --ring: 240 4.9% 83.9%;
        }

        body.modern-mode nav {
            background: hsl(var(--card));
            border: none;
            border-bottom: 1px solid hsl(var(--border));
            border-radius: 0;
            padding: 12px 24px;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        body.modern-mode nav a {
            color: hsl(var(--muted-foreground));
            text-decoration: none;
            padding: 8px 16px;
            border-radius: var(--radius);
            font-weight: 500;
            font-size: 14px;
            transition: all 0.15s ease;
            margin: 0 2px;
        }

        body.modern-mode nav a:hover {
            color: hsl(var(--foreground));
            background: hsl(var(--accent));
        }

        body.modern-mode nav a.active {
            color: hsl(var(--foreground));
            background: hsl(var(--accent));
            font-weight: 600;
        }

        body.modern-mode .dark-toggle,
        body.modern-mode .style-toggle {
            background: hsl(var(--secondary));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 6px 12px;
            color: hsl(var(--secondary-foreground));
            font-weight: 500;
            font-size: 12px;
            transition: all 0.15s ease;
        }

        body.modern-mode .dark-toggle:hover,
        body.modern-mode .style-toggle:hover {
            background: hsl(var(--accent));
        }

        body.modern-mode #content {
            padding: 32px;
            max-width: 1000px;
        }

        body.modern-mode .content-box {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: calc(var(--radius) * 2);
            padding: 32px;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }

        body.modern-mode .content-box::before,
        body.modern-mode .content-box::after {
            display: none;
        }

        /* shadcn Typography */
        body.modern-mode h2 {
            font-size: 1.875rem;
            font-weight: 600;
            letter-spacing: -0.025em;
            color: hsl(var(--foreground));
            margin-bottom: 1rem;
        }

        body.modern-mode h3 {
            font-size: 1.25rem;
            font-weight: 600;
            letter-spacing: -0.025em;
            color: hsl(var(--foreground));
            margin: 1.5rem 0 0.75rem;
        }

        body.modern-mode h4 {
            font-size: 1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }

        body.modern-mode p {
            color: hsl(var(--muted-foreground));
            line-height: 1.625;
        }

        /* shadcn Links */
        body.modern-mode a:not(nav a) {
            color: hsl(var(--foreground));
            text-decoration: underline;
            text-underline-offset: 4px;
            transition: opacity 0.15s;
        }

        body.modern-mode a:not(nav a):hover {
            opacity: 0.8;
        }

        /* shadcn Buttons */
        body.modern-mode button:not(.dark-toggle):not(.style-toggle) {
            font-family: inherit;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            font-size: 14px;
            font-weight: 500;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            border-radius: var(--radius);
            padding: 8px 16px;
            cursor: pointer;
            transition: opacity 0.15s ease;
            outline: none;
        }

        body.modern-mode button:not(.dark-toggle):not(.style-toggle):hover {
            opacity: 0.9;
        }

        body.modern-mode button:not(.dark-toggle):not(.style-toggle):focus-visible {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
        }

        body.modern-mode button:not(.dark-toggle):not(.style-toggle):active {
            opacity: 0.8;
        }

        /* Secondary/outline button variant */
        body.modern-mode button.secondary,
        body.modern-mode .toggle-btn {
            background: hsl(var(--secondary)) !important;
            color: hsl(var(--secondary-foreground)) !important;
            border: 1px solid hsl(var(--border)) !important;
        }

        body.modern-mode button.secondary:hover,
        body.modern-mode .toggle-btn:hover {
            background: hsl(var(--accent)) !important;
        }

        /* Destructive button */
        body.modern-mode button[style*="ffcccc"] {
            background: hsl(0 84.2% 60.2%) !important;
            color: hsl(0 0% 98%) !important;
        }

        /* shadcn Inputs */
        body.modern-mode input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: hsl(var(--secondary));
            height: 8px;
            border-radius: 0;
            cursor: pointer;
        }

        body.modern-mode input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 0;
            background: hsl(var(--background));
            border: 2px solid hsl(var(--primary));
            cursor: pointer;
            transition: all 0.15s;
        }

        body.modern-mode input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        body.modern-mode input[type="text"],
        body.modern-mode input[type="number"],
        body.modern-mode textarea {
            font-family: inherit;
            background: hsl(var(--background));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 8px 12px;
            font-size: 14px;
            color: hsl(var(--foreground));
            transition: border-color 0.15s, box-shadow 0.15s;
            outline: none;
        }

        body.modern-mode input[type="text"]:focus,
        body.modern-mode input[type="number"]:focus,
        body.modern-mode textarea:focus {
            border-color: hsl(var(--ring));
            box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);
        }

        body.modern-mode select {
            font-family: inherit;
            background: hsl(var(--background));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 8px 32px 8px 12px;
            font-size: 14px;
            cursor: pointer;
            color: hsl(var(--foreground));
            transition: border-color 0.15s;
            outline: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2371717a' stroke-width='2'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            -webkit-appearance: none;
            appearance: none;
        }

        body.modern-mode select:focus {
            border-color: hsl(var(--ring));
            box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);
        }

        /* shadcn Cards */
        body.modern-mode .quote {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: calc(var(--radius) * 1.5);
            padding: 20px;
            margin: 16px 0;
        }

        body.modern-mode .quote p:first-child {
            color: hsl(var(--foreground));
            font-style: italic;
        }

        body.modern-mode .quote .attribution {
            color: hsl(var(--muted-foreground));
            font-size: 14px;
            margin-top: 12px;
        }

        /* Canvas containers */
        body.modern-mode .canvas-container,
        body.modern-mode .globe-wrapper {
            border-radius: calc(var(--radius) * 2);
            overflow: hidden;
            border: 1px solid hsl(var(--border));
        }

        /* Panels and sidebars */
        body.modern-mode .neuron-panel,
        body.modern-mode .params-panel,
        body.modern-mode .side-panel > div {
            background: hsl(var(--card)) !important;
            border: 1px solid hsl(var(--border)) !important;
            border-radius: calc(var(--radius) * 1.5) !important;
        }

        /* Info boxes */
        body.modern-mode .model-info {
            background: hsl(var(--muted));
            border: 1px solid hsl(var(--border));
            border-radius: calc(var(--radius) * 1.5);
        }

        body.modern-mode .model-info-header {
            background: transparent !important;
            border-bottom: 1px solid hsl(var(--border));
        }

        /* Tables */
        body.modern-mode table {
            border-collapse: collapse;
            width: 100%;
        }

        body.modern-mode th,
        body.modern-mode td {
            border: 1px solid hsl(var(--border));
            padding: 8px 12px;
            text-align: left;
        }

        body.modern-mode th {
            background: hsl(var(--muted));
            font-weight: 600;
        }

        body.modern-mode tr:hover {
            background: hsl(var(--muted) / 0.5);
        }

        /* Scrollbar */
        body.modern-mode ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        body.modern-mode ::-webkit-scrollbar-track {
            background: transparent;
        }

        body.modern-mode ::-webkit-scrollbar-thumb {
            background: hsl(var(--border));
            border-radius: 0;
        }

        body.modern-mode ::-webkit-scrollbar-thumb:hover {
            background: hsl(var(--muted-foreground));
        }

        /* Animation */
        body.modern-mode .content-box {
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Social links */
        body.modern-mode .social-links a {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: hsl(var(--secondary));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            margin: 0 4px;
            transition: all 0.15s;
            text-decoration: none !important;
        }

        body.modern-mode .social-links a:hover {
            background: hsl(var(--accent));
            border-color: hsl(var(--foreground) / 0.2);
        }

        body.modern-mode .social-links svg {
            fill: hsl(var(--foreground));
            width: 18px;
            height: 18px;
        }

        /* Badge/Label styles */
        body.modern-mode .neuron-type-indicator {
            display: inline-flex;
            align-items: center;
            border-radius: 0;
            padding: 2px 10px;
            font-size: 12px;
            font-weight: 500;
        }

        body.modern-mode .neuron-type-indicator.excitatory {
            background: hsl(142.1 76.2% 36.3% / 0.1);
            color: hsl(142.1 76.2% 36.3%);
        }

        body.modern-mode .neuron-type-indicator.inhibitory {
            background: hsl(0 84.2% 60.2% / 0.1);
            color: hsl(0 84.2% 60.2%);
        }

        /* Separator */
        body.modern-mode hr {
            border: none;
            border-top: 1px solid hsl(var(--border));
            margin: 24px 0;
        }

        /* Code blocks */
        body.modern-mode code {
            background: hsl(var(--muted));
            padding: 2px 6px;
            border-radius: 0;
            font-size: 13px;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        #content {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }

        /* Brain, Math, and Globe pages get full width */
        #content:has(.brain-page),
        #content:has(.math-page),
        #content:has(.globe-page) {
            max-width: none;
        }

        .content-box {
            border: 2px solid var(--content-border);
            padding: 20px;
            background: var(--content-bg);
            position: relative;
            overflow: hidden;
            transition: background-color 0.3s, border-color 0.3s;
        }

        /* Brain page specific overrides */
        .content-box.brain-page {
            padding: 10px;
        }

        /* Math page specific overrides */
        .content-box.math-page {
            padding: 10px;
        }

        /* Globe page specific overrides */
        .content-box.globe-page {
            padding: 15px;
        }

        .content-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--content-bg);
            background-image: 
                /* Main pixel grid */
                linear-gradient(90deg, var(--pixel-color) 1px, transparent 1px),
                linear-gradient(var(--pixel-color) 1px, transparent 1px),
                /* Dithering pattern - checkerboard at different scales */
                repeating-conic-gradient(from 0deg at 50% 50%, transparent 0deg 90deg, var(--pixel-color) 90deg 180deg),
                /* Scattered pixel clusters */
                radial-gradient(circle at 15% 20%, var(--pixel-dot) 1px, transparent 1px),
                radial-gradient(circle at 85% 15%, var(--pixel-dot) 1px, transparent 1px),
                radial-gradient(circle at 45% 80%, var(--pixel-dot) 1px, transparent 1px),
                radial-gradient(circle at 70% 60%, var(--pixel-dot) 1px, transparent 1px),
                radial-gradient(circle at 25% 55%, var(--pixel-dot) 1px, transparent 1px),
                radial-gradient(circle at 90% 85%, var(--pixel-dot) 1px, transparent 1px),
                radial-gradient(circle at 10% 90%, var(--pixel-dot) 1px, transparent 1px),
                radial-gradient(circle at 55% 30%, var(--pixel-dot) 1px, transparent 1px),
                radial-gradient(circle at 35% 10%, var(--pixel-dot) 1px, transparent 1px),
                radial-gradient(circle at 80% 40%, var(--pixel-dot) 1px, transparent 1px);
            background-size: 
                8px 8px,
                8px 8px,
                4px 4px,
                100% 100%,
                100% 100%,
                100% 100%,
                100% 100%,
                100% 100%,
                100% 100%,
                100% 100%,
                100% 100%,
                100% 100%,
                100% 100%;
            pointer-events: none;
            z-index: 1;
            image-rendering: pixelated;
            transition: background-color 0.3s;
        }

        /* Scanline overlay */
        .content-box::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.015) 2px,
                rgba(0,0,0,0.015) 4px
            );
            pointer-events: none;
            z-index: 1;
        }

        .content-box > * {
            position: relative;
            z-index: 2;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <nav>
        <div class="nav-links">
            <a href="#" onclick="loadTab('intro')" class="active" id="intro-tab">Intro</a>
            <a href="#" onclick="loadTab('telos')" id="telos-tab">Stuff</a>
            <a href="#" onclick="loadTab('globe')" id="globe-tab">Globe</a>
            <a href="#" onclick="loadTab('brain')" id="brain-tab">Brain</a>
            <a href="#" onclick="loadTab('math')" id="math-tab">Math</a>
        </div>
        <button class="dark-toggle" onclick="toggleDarkMode()" id="dark-toggle">DARK</button>
        <button class="style-toggle" onclick="toggleStyleMode()" id="style-toggle">MODERN</button>
    </nav>

    <div id="content">
        <div class="content-box">
            <div class="loading">Loading...</div>
        </div>
    </div>

    <script>
        console.log('Script starting...');
        let currentTab = 'intro';

        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            const toggle = document.getElementById('dark-toggle');
            toggle.textContent = isDark ? 'LIGHT' : 'DARK';
            localStorage.setItem('darkMode', isDark ? 'true' : 'false');
        }

        // Style mode toggle (analog/modern)
        function toggleStyleMode() {
            document.body.classList.toggle('modern-mode');
            const isModern = document.body.classList.contains('modern-mode');
            const toggle = document.getElementById('style-toggle');
            toggle.textContent = isModern ? 'ANALOG' : 'MODERN';
            localStorage.setItem('modernMode', isModern ? 'true' : 'false');
        }

        // Check for saved dark mode preference (default to dark)
        if (localStorage.getItem('darkMode') !== 'false') {
            document.body.classList.add('dark-mode');
            document.getElementById('dark-toggle').textContent = 'LIGHT';
        }
        
        // Check for saved style mode preference
        if (localStorage.getItem('modernMode') === 'true') {
            document.body.classList.add('modern-mode');
            document.getElementById('style-toggle').textContent = 'ANALOG';
        }

        async function loadTab(tabName) {
            console.log('loadTab called:', tabName);
            try {
                // Cleanup previous tab if needed
                if (window.brainSimulatorCleanup) {
                    window.brainSimulatorCleanup();
                    window.brainSimulatorCleanup = null;
                }
                
                // Update active tab styling
                document.querySelectorAll('nav a').forEach(link => link.classList.remove('active'));
                document.getElementById(tabName + '-tab').classList.add('active');

                // Show loading
                document.getElementById('content').innerHTML = '<div class="content-box"><div class="loading">Loading...</div></div>';

                // Load the HTML file
                const response = await fetch(`${tabName}.html`);
                if (!response.ok) throw new Error('Failed to load page');
                
                const html = await response.text();
                document.getElementById('content').innerHTML = html;


                // If it's the brain tab, initialize the brain simulator
                if (tabName === 'brain') {
                    initializeBrainSimulator();
                }

                // If it's the intro tab, initialize the brain viewer
                if (tabName === 'intro') {
                    try {
                        initializeBrainViewer();
                    } catch (e) {
                        console.error('Brain viewer init error:', e);
                    }
                }

                // If it's the math tab, initialize the math visualizer
                if (tabName === 'math') {
                    try {
                        initializeMathVisualizer();
                    } catch (e) {
                        console.error('Math init error:', e);
                    }
                }

                // If it's the globe tab, initialize the globe
                if (tabName === 'globe') {
                    try {
                        initializeGlobe();
                    } catch (e) {
                        console.error('Globe init error:', e);
                    }
                }

                currentTab = tabName;
            } catch (error) {
                console.error('Error loading tab:', tabName, error);
                document.getElementById('content').innerHTML = `
                    <div class="content-box">
                        <p>Error loading ${tabName}.html: ${error.message}</p>
                        <p>Make sure the file exists in the same directory.</p>
                    </div>
                `;
            }
        }

        function initializeWidgets() {
            // Reset widget variables
            window.calcExpression = '';
            window.counterValue = 0;
            window.isDrawing = false;

            // Initialize clock
            updateClock();
            setInterval(updateClock, 1000);

            // Initialize canvas
            initCanvas();
        }

        // Widget functions (moved from original file)
        function calcInput(value) {
            const display = document.getElementById('calc-display');
            if (window.calcExpression === '0' || window.calcExpression === 'Error') {
                window.calcExpression = '';
            }
            window.calcExpression += value;
            display.textContent = window.calcExpression || '0';
        }

        function clearCalc() {
            window.calcExpression = '';
            document.getElementById('calc-display').textContent = '0';
        }

        function deleteLast() {
            window.calcExpression = window.calcExpression.slice(0, -1);
            document.getElementById('calc-display').textContent = window.calcExpression || '0';
        }

        function calculate() {
            const display = document.getElementById('calc-display');
            try {
                const result = eval(window.calcExpression.replace('×', '*'));
                window.calcExpression = result.toString();
                display.textContent = window.calcExpression;
            } catch (e) {
                display.textContent = 'Error';
                window.calcExpression = 'Error';
            }
        }

        function updateClock() {
            const now = new Date();
            const time = now.toLocaleTimeString();
            const clockElement = document.getElementById('clock');
            if (clockElement) {
                clockElement.textContent = time;
            }
        }

        function initCanvas() {
            const canvas = document.getElementById('canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');

            canvas.addEventListener('mousedown', (e) => {
                window.isDrawing = true;
                draw(e);
            });

            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', () => window.isDrawing = false);
            canvas.addEventListener('mouseout', () => window.isDrawing = false);

            function draw(e) {
                if (!window.isDrawing) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                ctx.lineWidth = document.getElementById('brush-size').value;
                ctx.lineCap = 'round';
                ctx.strokeStyle = document.getElementById('brush-color').value;

                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y);
            }
        }

        function clearCanvas() {
            const canvas = document.getElementById('canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
        }

        function changeCounter(amount) {
            window.counterValue += amount;
            document.getElementById('counter-display').textContent = window.counterValue;
        }

        function resetCounter() {
            window.counterValue = 0;
            document.getElementById('counter-display').textContent = window.counterValue;
        }

        // 3D Object initialization function
        function initialize3DObject() {
            setTimeout(() => {
                const canvas = document.getElementById('canvas3d');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Icosahedron vertices (golden ratio based)
                const phi = (1 + Math.sqrt(5)) / 2;
                const vertices = [
                    [-1, phi, 0], [1, phi, 0], [-1, -phi, 0], [1, -phi, 0],
                    [0, -1, phi], [0, 1, phi], [0, -1, -phi], [0, 1, -phi],
                    [phi, 0, -1], [phi, 0, 1], [-phi, 0, -1], [-phi, 0, 1]
                ];
                
                // Icosahedron edges
                const edges = [
                    [0,11],[0,5],[0,1],[0,7],[0,10],
                    [1,5],[1,9],[1,7],[1,8],
                    [2,3],[2,4],[2,6],[2,10],[2,11],
                    [3,4],[3,6],[3,8],[3,9],
                    [4,5],[4,9],[4,11],
                    [5,9],[5,11],
                    [6,7],[6,8],[6,10],
                    [7,8],[7,10],
                    [8,9],[10,11]
                ];
                
                // State
                let rotationX = 0.3;
                let rotationY = 0.5;
                let rotationZ = 0;
                let scale = 60;
                let isDragging = false;
                let lastMouseX = 0;
                let lastMouseY = 0;
                let autoRotate = true;
                let animationId;
                
                // Rotation matrices
                function rotateX(point, angle) {
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    return [
                        point[0],
                        point[1] * cos - point[2] * sin,
                        point[1] * sin + point[2] * cos
                    ];
                }
                
                function rotateY(point, angle) {
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    return [
                        point[0] * cos + point[2] * sin,
                        point[1],
                        -point[0] * sin + point[2] * cos
                    ];
                }
                
                function rotateZ(point, angle) {
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    return [
                        point[0] * cos - point[1] * sin,
                        point[0] * sin + point[1] * cos,
                        point[2]
                    ];
                }
                
                // Project 3D to 2D (orthographic projection - no perspective distortion)
                function project(point) {
                    return [
                        centerX + point[0] * scale,
                        centerY + point[1] * scale,
                        point[2]
                    ];
                }
                
                function render() {
                    // Clear with dark background
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, width, height);
                    
                    // Draw grid (pixelated look)
                    ctx.strokeStyle = 'rgba(50, 50, 50, 0.5)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < width; i += 20) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, height);
                        ctx.stroke();
                    }
                    for (let i = 0; i < height; i += 20) {
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(width, i);
                        ctx.stroke();
                    }
                    
                    // Transform vertices
                    const transformed = vertices.map(v => {
                        let p = [...v];
                        p = rotateX(p, rotationX);
                        p = rotateY(p, rotationY);
                        p = rotateZ(p, rotationZ);
                        return project(p);
                    });
                    
                    // Sort edges by average Z for depth
                    const sortedEdges = edges.map(e => ({
                        edge: e,
                        avgZ: (transformed[e[0]][2] + transformed[e[1]][2]) / 2
                    })).sort((a, b) => b.avgZ - a.avgZ);
                    
                    // Draw edges
                    sortedEdges.forEach(({edge, avgZ}) => {
                        const [i, j] = edge;
                        const p1 = transformed[i];
                        const p2 = transformed[j];
                        
                        // Color based on depth
                        const depthFactor = Math.max(0.2, Math.min(1, (avgZ - 2) / 4));
                        const r = Math.floor(100 + 155 * depthFactor);
                        const g = Math.floor(200 * depthFactor);
                        const b = Math.floor(255 * depthFactor);
                        
                        ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.lineWidth = 1 + depthFactor;
                        ctx.beginPath();
                        ctx.moveTo(Math.floor(p1[0]), Math.floor(p1[1]));
                        ctx.lineTo(Math.floor(p2[0]), Math.floor(p2[1]));
                        ctx.stroke();
                    });
                    
                    // Draw vertices
                    transformed.forEach((p, i) => {
                        const depthFactor = Math.max(0.3, Math.min(1, (p[2] - 2) / 4));
                        const size = 2 + depthFactor * 3;
                        
                        // Glow effect
                        ctx.fillStyle = `rgba(0, 255, 200, ${depthFactor * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(p[0], p[1], size * 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Main vertex
                        ctx.fillStyle = `rgba(150, 255, 220, ${depthFactor})`;
                        ctx.beginPath();
                        ctx.arc(p[0], p[1], size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Auto rotation
                    if (autoRotate && !isDragging) {
                        rotationY += 0.005;
                        rotationX += 0.002;
                    }
                    
                    animationId = requestAnimationFrame(render);
                }
                
                // Mouse events
                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    autoRotate = false;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    rotationY += deltaX * 0.01;
                    rotationX += deltaY * 0.01;
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                    // Resume auto-rotate after 3 seconds of no interaction
                    setTimeout(() => {
                        if (!isDragging) autoRotate = true;
                    }, 3000);
                });
                
                canvas.addEventListener('mouseleave', () => {
                    isDragging = false;
                });
                
                // Scroll to zoom
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    scale += e.deltaY > 0 ? -5 : 5;
                    scale = Math.max(30, Math.min(120, scale));
                }, { passive: false });
                
                // Touch support
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    isDragging = true;
                    autoRotate = false;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                }, { passive: false });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!isDragging) return;
                    
                    const deltaX = e.touches[0].clientX - lastMouseX;
                    const deltaY = e.touches[0].clientY - lastMouseY;
                    
                    rotationY += deltaX * 0.01;
                    rotationX += deltaY * 0.01;
                    
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                }, { passive: false });
                
                canvas.addEventListener('touchend', () => {
                    isDragging = false;
                    setTimeout(() => {
                        if (!isDragging) autoRotate = true;
                    }, 3000);
                });
                
                // Start rendering
                render();
            }, 50);
        }

        // Brain 3D Viewer using Three.js
        function initializeBrainViewer() {
            const container = document.getElementById('brainContainer');
            if (!container) return;
            
            // Load Three.js dynamically
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
            script.onload = () => {
                // Load GLTFLoader
                const loaderScript = document.createElement('script');
                loaderScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js';
                loaderScript.onload = () => initThreeJS();
                document.head.appendChild(loaderScript);
            };
            document.head.appendChild(script);
            
            function initThreeJS() {
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                // Scene
                const scene = new THREE.Scene();
                
                // Camera
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                camera.position.set(0, 0, 25);
                
                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setClearColor(0x000000, 0);
                container.appendChild(renderer.domElement);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7);
                scene.add(directionalLight);
                
                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-5, -5, -5);
                scene.add(backLight);
                
                // Brain model
                let brain = null;
                let autoRotate = true;
                let isDragging = false;
                let previousMouseX = 0;
                let previousMouseY = 0;
                const initialDistance = 25;
                const maxDistance = 25;
                const minDistance = 15;
                
                // Material - changes based on dark/light mode
                function getBrainMaterial() {
                    const isDarkMode = document.body.classList.contains('dark-mode');
                    return new THREE.MeshStandardMaterial({
                        color: isDarkMode ? 0xeeeeee : 0xffb6c1,  // White in dark, pink in light
                        roughness: 0.6,
                        metalness: 0.1,
                        flatShading: false
                    });
                }
                
                // Load GLB model
                const loader = new THREE.GLTFLoader();
                loader.load('brain.glb', 
                    (gltf) => {
                        brain = gltf.scene;
                        brain.traverse((child) => {
                            if (child.isMesh) {
                                child.material = getBrainMaterial();
                            }
                        });
                        brain.rotation.x = -0.3;
                        scene.add(brain);
                    },
                    (progress) => {},
                    (error) => console.error('Error loading brain:', error)
                );
                
                // Update material when dark mode changes
                const observer = new MutationObserver(() => {
                    if (brain) {
                        brain.traverse((child) => {
                            if (child.isMesh) {
                                child.material = getBrainMaterial();
                            }
                        });
                    }
                });
                observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
                
                // Mouse controls
                container.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    autoRotate = false;
                    previousMouseX = e.clientX;
                    previousMouseY = e.clientY;
                });
                
                container.addEventListener('mousemove', (e) => {
                    if (!isDragging || !brain) return;
                    const deltaX = e.clientX - previousMouseX;
                    const deltaY = e.clientY - previousMouseY;
                    brain.rotation.y += deltaX * 0.01;
                    brain.rotation.x += deltaY * 0.01;
                    previousMouseX = e.clientX;
                    previousMouseY = e.clientY;
                });
                
                container.addEventListener('mouseup', () => isDragging = false);
                container.addEventListener('mouseleave', () => isDragging = false);
                
                // Touch controls
                container.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    autoRotate = false;
                    previousMouseX = e.touches[0].clientX;
                    previousMouseY = e.touches[0].clientY;
                });
                
                container.addEventListener('touchmove', (e) => {
                    if (!isDragging || !brain) return;
                    e.preventDefault();
                    const deltaX = e.touches[0].clientX - previousMouseX;
                    const deltaY = e.touches[0].clientY - previousMouseY;
                    brain.rotation.y += deltaX * 0.01;
                    brain.rotation.x += deltaY * 0.01;
                    previousMouseX = e.touches[0].clientX;
                    previousMouseY = e.touches[0].clientY;
                }, { passive: false });
                
                container.addEventListener('touchend', () => isDragging = false);
                
                // Zoom
                container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    camera.position.z += e.deltaY * 0.02;
                    camera.position.z = Math.max(minDistance, Math.min(maxDistance, camera.position.z));
                }, { passive: false });
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    if (brain && autoRotate) {
                        brain.rotation.y += 0.003;
                    }
                    
                    renderer.render(scene, camera);
                }
                animate();
                
                // Handle resize
                window.addEventListener('resize', () => {
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                });
            }
        }

        // Math Visualizer initialization function
        function initializeMathVisualizer() {
            setTimeout(() => {
                const canvas = document.getElementById('mathCanvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                // Resize canvas to match displayed size
                function resizeCanvas() {
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                }
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                let width = canvas.width;
                let height = canvas.height;
                let centerX = width / 2;
                let centerY = height / 2;
                
                // State
                let rotationX = 0.5;
                let rotationY = 0.3;
                let scale = 80;
                let isDragging = false;
                let lastMouseX = 0;
                let lastMouseY = 0;
                let autoRotate = true;
                let currentSurface = 'lorenz';
                let paramA = 1.0;
                let paramB = 1.0;
                
                // Cached data for slow computations
                let cachedBifurcation = null;
                let cachedBifurcationParams = null;
                let cachedArnold = null;
                let cachedArnoldParams = null;
                let paramC = 1.0;
                let resolution = 30;
                let showWireframe = true;
                let showPoints = false;
                
                // Surface equations
                const surfaces = {
                    torus: {
                        name: 'Torus',
                        equations: 'x = (R + r·cos(v))·cos(u)<br>y = (R + r·cos(v))·sin(u)<br>z = r·sin(v)',
                        params: { a: 'Major Radius (R)', b: 'Minor Radius (r)', c: null, res: true },
                        generate: (u, v, a, b, c) => {
                            return [
                                (a + b * Math.cos(v)) * Math.cos(u),
                                (a + b * Math.cos(v)) * Math.sin(u),
                                b * Math.sin(v)
                            ];
                        },
                        uRange: [0, 2 * Math.PI],
                        vRange: [0, 2 * Math.PI]
                    },
                    sphere: {
                        name: 'Sphere',
                        equations: 'x = r·sin(v)·cos(u)<br>y = r·sin(v)·sin(u)<br>z = r·cos(v)',
                        params: { a: 'Radius (r)', b: null, c: null, res: true },
                        generate: (u, v, a, b, c) => {
                            return [
                                a * Math.sin(v) * Math.cos(u),
                                a * Math.sin(v) * Math.sin(u),
                                a * Math.cos(v)
                            ];
                        },
                        uRange: [0, 2 * Math.PI],
                        vRange: [0, Math.PI]
                    },
                    mobius: {
                        name: 'Mobius Strip',
                        equations: 'x = (1 + s·cos(u/2))·cos(u)<br>y = (1 + s·cos(u/2))·sin(u)<br>z = s·sin(u/2)',
                        params: { a: 'Size', b: 'Width', c: null, res: true },
                        generate: (u, v, a, b, c) => {
                            return [
                                (a + (v * b) * Math.cos(u / 2)) * Math.cos(u),
                                (a + (v * b) * Math.cos(u / 2)) * Math.sin(u),
                                (v * b) * Math.sin(u / 2)
                            ];
                        },
                        uRange: [0, 2 * Math.PI],
                        vRange: [-1, 1]
                    },
                    klein: {
                        name: 'Klein Bottle',
                        equations: 'Immersion in 3D<br>(self-intersecting)',
                        params: { a: 'Scale', b: null, c: null, res: true },
                        generate: (u, v, a, b, c) => {
                            const r = a * 0.5;
                            let x, y, z;
                            if (u < Math.PI) {
                                x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v);
                                z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
                            } else {
                                x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);
                                z = -8 * Math.sin(u);
                            }
                            y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);
                            return [x * r * 0.15, y * r, z * r * 0.15];
                        },
                        uRange: [0, 2 * Math.PI],
                        vRange: [0, 2 * Math.PI]
                    },
                    trefoil: {
                        name: 'Trefoil Knot',
                        equations: 'x = sin(t) + 2·sin(2t)<br>y = cos(t) - 2·cos(2t)<br>z = -sin(3t)',
                        params: { a: 'Scale', b: 'Tube Radius', c: null, res: true },
                        generate: (u, v, a, b, c) => {
                            const t = u;
                            const r = b * 0.3;
                            const x = Math.sin(t) + 2 * Math.sin(2 * t);
                            const y = Math.cos(t) - 2 * Math.cos(2 * t);
                            const z = -Math.sin(3 * t);
                            return [
                                (x + r * Math.cos(v)) * a * 0.5,
                                (y + r * Math.sin(v)) * a * 0.5,
                                z * a * 0.5
                            ];
                        },
                        uRange: [0, 2 * Math.PI],
                        vRange: [0, 2 * Math.PI]
                    },
                    saddle: {
                        name: 'Saddle',
                        equations: 'z = a·x² - b·y²',
                        params: { a: 'X Curvature', b: 'Y Curvature', c: null, res: true },
                        generate: (u, v, a, b, c) => {
                            return [u, v, a * 0.3 * (u * u - b * v * v)];
                        },
                        uRange: [-2, 2],
                        vRange: [-2, 2]
                    },
                    helix: {
                        name: 'Double Helix',
                        equations: 'x = r·cos(ωt), y = r·sin(ωt), z = t<br>(two intertwined)',
                        params: { a: 'Radius', b: 'Pitch', c: 'Twist Rate', res: false },
                        generate: (u, v, a, b, c) => {
                            const offset = v < 0.5 ? 0 : Math.PI;
                            return [
                                a * Math.cos(u * c + offset),
                                a * Math.sin(u * c + offset),
                                u * b * 0.3
                            ];
                        },
                        uRange: [-4, 4],
                        vRange: [0, 1]
                    },
                    lorenz: {
                        name: 'Lorenz Attractor',
                        equations: 'dx/dt = σ(y-x)<br>dy/dt = x(ρ-z)-y<br>dz/dt = xy - βz',
                        params: { a: 'σ (sigma)', b: 'ρ (rho)', c: 'β (beta)', res: false },
                        generate: null
                    },
                    digamma: {
                        name: 'Digamma Function',
                        equations: 'ψ(z) = d/dz ln(Γ(z))<br>z = x + iy (complex)',
                        params: { a: 'Scale', b: null, c: null, res: true },
                        generate: (u, v, a, b, c) => {
                            // Digamma approximation using asymptotic series
                            // For real part of digamma(x + iy)
                            const x = u * a;
                            const y = v * a;
                            
                            // Use reflection and recurrence to handle all values
                            let realPart = 0;
                            let px = x, py = y;
                            
                            // Shift to positive real part using recurrence
                            while (px < 5) {
                                const denom = px * px + py * py;
                                if (denom > 0.0001) {
                                    realPart -= px / denom;
                                }
                                px += 1;
                            }
                            
                            // Asymptotic expansion for large |z|
                            const r2 = px * px + py * py;
                            realPart += 0.5 * Math.log(r2);
                            realPart -= 0.5 * px / r2;
                            realPart -= (px * px - py * py) / (12 * r2 * r2);
                            
                            return [u, v, realPart * 0.3];
                        },
                        uRange: [-3, 3],
                        vRange: [-3, 3]
                    },
                    sinc: {
                        name: 'Sinc Function',
                        equations: 'z = A·sin(ωr)/r<br>r = √(x² + y²)',
                        params: { a: 'Amplitude', b: null, c: 'Frequency', res: true },
                        generate: (u, v, a, b, c) => {
                            const r = Math.sqrt(u * u + v * v) * c + 0.001;
                            return [u, v, a * Math.sin(r * 3) / r];
                        },
                        uRange: [-3, 3],
                        vRange: [-3, 3]
                    },
                    wave: {
                        name: 'Wave Interference',
                        equations: 'z = sin(ωr₁) + sin(ωr₂)<br>Two point sources',
                        params: { a: 'Amplitude', b: null, c: 'Frequency', res: true },
                        generate: (u, v, a, b, c) => {
                            const r1 = Math.sqrt((u - 1) * (u - 1) + v * v) * c * 2;
                            const r2 = Math.sqrt((u + 1) * (u + 1) + v * v) * c * 2;
                            return [u, v, a * 0.3 * (Math.sin(r1) + Math.sin(r2))];
                        },
                        uRange: [-3, 3],
                        vRange: [-3, 3]
                    },
                    bifurcation: {
                        name: 'Bifurcation Diagram',
                        equations: 'x_{n+1} = r·x_n·(1 - x_n)<br>Logistic map',
                        params: { a: 'r min', b: 'r max', c: null, res: false },
                        generate: null,
                        is2D: true
                    },
                    arnold: {
                        name: 'Arnold Tongues',
                        equations: 'θ_{n+1} = θ_n + Ω - (K/2π)·sin(2πθ_n)<br>Circle map',
                        params: { a: 'Max K', b: null, c: null, res: false },
                        generate: null,
                        is2D: true
                    },
                    langton: {
                        name: "Langton's Ant",
                        equations: 'On white: turn right, flip, move<br>On black: turn left, flip, move',
                        params: { a: 'Steps/Frame', b: 'Grid Size', c: null, res: false },
                        generate: null,
                        is2D: true,
                        isAnimated: true
                    }
                };
                
                // Langton's Ant state
                let langtonGrid = null;
                let langtonAnt = null;
                let langtonSteps = 0;
                let langtonGridSize = 150;
                let langtonStepsPerFrame = 50;
                
                function initLangton(gridSize) {
                    langtonGridSize = gridSize;
                    langtonGrid = new Uint8Array(gridSize * gridSize);
                    langtonAnt = {
                        x: Math.floor(gridSize / 2),
                        y: Math.floor(gridSize / 2),
                        dir: 0 // 0=up, 1=right, 2=down, 3=left
                    };
                    langtonSteps = 0;
                }
                
                function stepLangton() {
                    const { x, y, dir } = langtonAnt;
                    const idx = y * langtonGridSize + x;
                    const cell = langtonGrid[idx];
                    
                    // Turn based on current cell
                    if (cell === 0) {
                        // White cell: turn right
                        langtonAnt.dir = (dir + 1) % 4;
                    } else {
                        // Black cell: turn left
                        langtonAnt.dir = (dir + 3) % 4;
                    }
                    
                    // Flip the cell
                    langtonGrid[idx] = 1 - cell;
                    
                    // Move forward
                    const dx = [0, 1, 0, -1];
                    const dy = [-1, 0, 1, 0];
                    langtonAnt.x += dx[langtonAnt.dir];
                    langtonAnt.y += dy[langtonAnt.dir];
                    
                    // Wrap around edges
                    if (langtonAnt.x < 0) langtonAnt.x = langtonGridSize - 1;
                    if (langtonAnt.x >= langtonGridSize) langtonAnt.x = 0;
                    if (langtonAnt.y < 0) langtonAnt.y = langtonGridSize - 1;
                    if (langtonAnt.y >= langtonGridSize) langtonAnt.y = 0;
                    
                    langtonSteps++;
                }
                
                // Update parameter UI based on surface
                function updateParamUI(surfaceName) {
                    const surface = surfaces[surfaceName];
                    const params = surface.params;
                    
                    // Update labels and visibility
                    const paramAGroup = document.getElementById('paramAGroup');
                    const paramBGroup = document.getElementById('paramBGroup');
                    const paramCGroup = document.getElementById('paramCGroup');
                    const resGroup = document.getElementById('resGroup');
                    
                    if (params.a) {
                        paramAGroup.classList.remove('hidden');
                        document.getElementById('paramALabel').textContent = params.a;
                    } else {
                        paramAGroup.classList.add('hidden');
                    }
                    
                    if (params.b) {
                        paramBGroup.classList.remove('hidden');
                        document.getElementById('paramBLabel').textContent = params.b;
                    } else {
                        paramBGroup.classList.add('hidden');
                    }
                    
                    if (params.c) {
                        paramCGroup.classList.remove('hidden');
                        document.getElementById('paramCLabel').textContent = params.c;
                    } else {
                        paramCGroup.classList.add('hidden');
                    }
                    
                    if (params.res) {
                        resGroup.classList.remove('hidden');
                    } else {
                        resGroup.classList.add('hidden');
                    }
                    
                    // Show reset button for animated surfaces
                    const resetGroup = document.getElementById('resetGroup');
                    if (resetGroup) {
                        if (surface.isAnimated) {
                            resetGroup.classList.remove('hidden');
                        } else {
                            resetGroup.classList.add('hidden');
                        }
                    }
                    
                    // Set special defaults for bifurcation
                    if (surfaceName === 'bifurcation') {
                        document.getElementById('paramA').value = 2.5;
                        document.getElementById('paramA').min = 0;
                        document.getElementById('paramA').max = 4;
                        document.getElementById('paramAVal').textContent = '2.5';
                        paramA = 2.5;
                        
                        document.getElementById('paramB').value = 4;
                        document.getElementById('paramB').min = 0;
                        document.getElementById('paramB').max = 4;
                        document.getElementById('paramBVal').textContent = '4.0';
                        paramB = 4;
                    } else if (surfaceName === 'arnold') {
                        document.getElementById('paramA').value = 4;
                        document.getElementById('paramA').min = 1;
                        document.getElementById('paramA').max = 20;
                        document.getElementById('paramA').step = 1;
                        document.getElementById('paramAVal').textContent = '4.0';
                        paramA = 4;
                    } else if (surfaceName === 'langton') {
                        document.getElementById('paramA').value = 50;
                        document.getElementById('paramA').min = 1;
                        document.getElementById('paramA').max = 500;
                        document.getElementById('paramA').step = 10;
                        document.getElementById('paramAVal').textContent = '50';
                        langtonStepsPerFrame = 50;
                        
                        document.getElementById('paramB').value = 150;
                        document.getElementById('paramB').min = 50;
                        document.getElementById('paramB').max = 300;
                        document.getElementById('paramB').step = 10;
                        document.getElementById('paramBVal').textContent = '150';
                        
                        // Initialize Langton's Ant
                        initLangton(150);
                    } else {
                        // Reset to defaults
                        document.getElementById('paramA').min = 0.1;
                        document.getElementById('paramA').max = 5;
                        document.getElementById('paramB').min = 0.1;
                        document.getElementById('paramB').max = 2;
                    }
                }
                
                // Initial UI update
                updateParamUI('lorenz');
                
                // Generate Lorenz attractor points
                function generateLorenz(a, b, c) {
                    const points = [];
                    const sigma = 10 * a;
                    const rho = 28 * b;
                    const beta = 8/3 * c;
                    let x = 0.1, y = 0, z = 0;
                    const dt = 0.005;
                    
                    for (let i = 0; i < 5000; i++) {
                        const dx = sigma * (y - x);
                        const dy = x * (rho - z) - y;
                        const dz = x * y - beta * z;
                        x += dx * dt;
                        y += dy * dt;
                        z += dz * dt;
                        if (i > 100) {
                            points.push([x * 0.05, y * 0.05, (z - 25) * 0.05]);
                        }
                    }
                    return points;
                }
                
                // Generate bifurcation diagram points
                function generateBifurcationImageData(rMin, rMax, plotWidth, plotHeight) {
                    // Generate directly to ImageData for speed
                    const imageData = ctx.createImageData(plotWidth, plotHeight);
                    const data = imageData.data;
                    const rSteps = Math.min(plotWidth, 400);
                    const iterations = 80;
                    const settle = 40;
                    
                    for (let i = 0; i < rSteps; i++) {
                        const r = rMin + (rMax - rMin) * (i / rSteps);
                        const px = Math.floor((i / rSteps) * plotWidth);
                        let x = 0.5;
                        
                        for (let j = 0; j < settle; j++) {
                            x = r * x * (1 - x);
                        }
                        
                        for (let j = 0; j < iterations; j++) {
                            x = r * x * (1 - x);
                            if (x > 0 && x < 1) {
                                const py = Math.floor((1 - x) * plotHeight);
                                if (py >= 0 && py < plotHeight) {
                                    const idx = (py * plotWidth + px) * 4;
                                    // Amber color
                                    const hue = 35 + (r - rMin) / (rMax - rMin) * 45;
                                    const rgb = hslToRgb(hue / 360, 0.65, 0.55);
                                    data[idx] = rgb[0];
                                    data[idx + 1] = rgb[1];
                                    data[idx + 2] = rgb[2];
                                    data[idx + 3] = 200;
                                }
                            }
                        }
                    }
                    return imageData;
                }
                
                // HSL to RGB helper
                function hslToRgb(h, s, l) {
                    let r, g, b;
                    if (s === 0) { r = g = b = l; }
                    else {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1/6) return p + (q - p) * 6 * t;
                            if (t < 1/2) return q;
                            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        };
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        r = hue2rgb(p, q, h + 1/3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1/3);
                    }
                    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
                }
                
                // Generate Arnold tongues (circle map)
                function generateArnoldImageData(maxK, plotWidth, plotHeight) {
                    const imageData = ctx.createImageData(plotWidth, plotHeight);
                    const data = imageData.data;
                    const omegaSteps = Math.min(plotWidth, 300);
                    const kSteps = Math.min(plotHeight, 200);
                    const iterations = 40;
                    const settle = 20;
                    const rationals = [0, 1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5, 1];
                    const colors = [
                        [220, 60, 60], [220, 140, 60], [220, 200, 60], [140, 200, 60],
                        [60, 200, 60], [60, 200, 140], [60, 200, 220], [60, 140, 220],
                        [60, 60, 220], [140, 60, 220], [220, 60, 220]
                    ];
                    
                    for (let oi = 0; oi < omegaSteps; oi++) {
                        const omega = oi / omegaSteps;
                        const px = Math.floor((oi / omegaSteps) * plotWidth);
                        
                        for (let ki = 0; ki < kSteps; ki++) {
                            const K = (ki / kSteps) * maxK;
                            const py = Math.floor((1 - ki / kSteps) * plotHeight);
                            
                            let theta = 0.1;
                            for (let j = 0; j < settle; j++) {
                                theta = (theta + omega - (K / (2 * Math.PI)) * Math.sin(2 * Math.PI * theta)) % 1;
                                if (theta < 0) theta += 1;
                            }
                            
                            let totalRot = 0;
                            for (let j = 0; j < iterations; j++) {
                                const newT = theta + omega - (K / (2 * Math.PI)) * Math.sin(2 * Math.PI * theta);
                                totalRot += newT - theta;
                                theta = newT % 1;
                                if (theta < 0) theta += 1;
                            }
                            
                            const rotNum = totalRot / iterations;
                            let minDist = 1, lockedTo = 0;
                            for (let ri = 0; ri < rationals.length; ri++) {
                                const d = Math.abs(rotNum - rationals[ri]);
                                if (d < minDist) { minDist = d; lockedTo = ri; }
                            }
                            
                            if (minDist < 0.03 && py >= 0 && py < plotHeight && px >= 0 && px < plotWidth) {
                                const idx = (py * plotWidth + px) * 4;
                                const c = colors[lockedTo];
                                data[idx] = c[0];
                                data[idx + 1] = c[1];
                                data[idx + 2] = c[2];
                                data[idx + 3] = 220;
                            }
                        }
                    }
                    return imageData;
                }
                
                // Rotation functions
                function rotatePoint(p, rx, ry) {
                    let [x, y, z] = p;
                    // Rotate around X
                    let y1 = y * Math.cos(rx) - z * Math.sin(rx);
                    let z1 = y * Math.sin(rx) + z * Math.cos(rx);
                    // Rotate around Y
                    let x2 = x * Math.cos(ry) + z1 * Math.sin(ry);
                    let z2 = -x * Math.sin(ry) + z1 * Math.cos(ry);
                    return [x2, y1, z2];
                }
                
                function project(p) {
                    return [centerX + p[0] * scale, centerY - p[1] * scale, p[2]];
                }
                
                function render() {
                    // Update dimensions each frame
                    width = canvas.width;
                    height = canvas.height;
                    centerX = width / 2;
                    centerY = height / 2;
                    
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, width, height);
                    
                    // Draw grid (vintage amber tint)
                    ctx.strokeStyle = 'rgba(80, 60, 30, 0.25)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < width; i += 40) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, height);
                        ctx.stroke();
                    }
                    for (let i = 0; i < height; i += 40) {
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(width, i);
                        ctx.stroke();
                    }
                    
                    const surface = surfaces[currentSurface];
                    
                    if (currentSurface === 'bifurcation') {
                        // Bifurcation diagram (2D) - use cached ImageData
                        const rMin = paramA;
                        const rMax = paramB;
                        const margin = 50;
                        const plotWidth = Math.floor(width - 2 * margin);
                        const plotHeight = Math.floor(height - 2 * margin);
                        
                        // Check cache
                        const cacheKey = `${rMin}-${rMax}-${plotWidth}-${plotHeight}`;
                        if (!cachedBifurcation || cachedBifurcationParams !== cacheKey) {
                            cachedBifurcation = generateBifurcationImageData(rMin, rMax, plotWidth, plotHeight);
                            cachedBifurcationParams = cacheKey;
                        }
                        
                        ctx.putImageData(cachedBifurcation, margin, margin);
                        
                        // Draw axes
                        ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(margin, height - margin);
                        ctx.lineTo(width - margin, height - margin);
                        ctx.moveTo(margin, height - margin);
                        ctx.lineTo(margin, margin);
                        ctx.stroke();
                        
                        // Axis labels
                        ctx.fillStyle = 'rgba(150, 150, 150, 0.8)';
                        ctx.font = '12px Courier New';
                        ctx.fillText('r', width - margin + 10, height - margin);
                        ctx.fillText('x', margin - 5, margin - 10);
                        ctx.fillText(rMin.toFixed(1), margin, height - margin + 20);
                        ctx.fillText(rMax.toFixed(1), width - margin - 20, height - margin + 20);
                        ctx.fillText('0', margin - 20, height - margin);
                        ctx.fillText('1', margin - 20, margin + 10);
                        
                    } else if (currentSurface === 'arnold') {
                        // Arnold tongues - use cached ImageData
                        const maxK = paramA;
                        const margin = 50;
                        const plotWidth = Math.floor(width - 2 * margin);
                        const plotHeight = Math.floor(height - 2 * margin);
                        
                        // Check cache
                        const cacheKey = `${maxK}-${plotWidth}-${plotHeight}`;
                        if (!cachedArnold || cachedArnoldParams !== cacheKey) {
                            cachedArnold = generateArnoldImageData(maxK, plotWidth, plotHeight);
                            cachedArnoldParams = cacheKey;
                        }
                        
                        ctx.putImageData(cachedArnold, margin, margin);
                        
                        // Draw axes
                        ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(margin, height - margin);
                        ctx.lineTo(width - margin, height - margin);
                        ctx.moveTo(margin, height - margin);
                        ctx.lineTo(margin, margin);
                        ctx.stroke();
                        
                        // Axis labels
                        ctx.fillStyle = 'rgba(150, 150, 150, 0.8)';
                        ctx.font = '12px Courier New';
                        ctx.fillText('Ω', width - margin + 10, height - margin);
                        ctx.fillText('K', margin - 5, margin - 10);
                        ctx.fillText('0', margin, height - margin + 20);
                        ctx.fillText('1', width - margin - 10, height - margin + 20);
                        ctx.fillText('0', margin - 20, height - margin);
                        ctx.fillText(maxK.toFixed(1), margin - 25, margin + 10);
                        
                    } else if (currentSurface === 'langton') {
                        // Langton's Ant
                        if (!langtonGrid) {
                            initLangton(langtonGridSize);
                        }
                        
                        // Run steps
                        for (let i = 0; i < langtonStepsPerFrame; i++) {
                            stepLangton();
                        }
                        
                        // Calculate cell size to fit canvas
                        const margin = 30;
                        const availableSize = Math.min(width, height) - 2 * margin;
                        const cellSize = availableSize / langtonGridSize;
                        const offsetX = (width - availableSize) / 2;
                        const offsetY = (height - availableSize) / 2;
                        
                        // Draw grid using ImageData for speed
                        const imageData = ctx.createImageData(Math.ceil(availableSize), Math.ceil(availableSize));
                        const data = imageData.data;
                        
                        for (let y = 0; y < langtonGridSize; y++) {
                            for (let x = 0; x < langtonGridSize; x++) {
                                const cell = langtonGrid[y * langtonGridSize + x];
                                const px = Math.floor(x * cellSize);
                                const py = Math.floor(y * cellSize);
                                const pxEnd = Math.floor((x + 1) * cellSize);
                                const pyEnd = Math.floor((y + 1) * cellSize);
                                
                                // Color: white = amber, black = dark
                                const r = cell === 0 ? 200 : 20;
                                const g = cell === 0 ? 160 : 15;
                                const b = cell === 0 ? 60 : 10;
                                
                                for (let py2 = py; py2 < pyEnd && py2 < availableSize; py2++) {
                                    for (let px2 = px; px2 < pxEnd && px2 < availableSize; px2++) {
                                        const idx = (py2 * Math.ceil(availableSize) + px2) * 4;
                                        data[idx] = r;
                                        data[idx + 1] = g;
                                        data[idx + 2] = b;
                                        data[idx + 3] = 255;
                                    }
                                }
                            }
                        }
                        
                        // Draw ant position
                        const antPx = Math.floor(langtonAnt.x * cellSize);
                        const antPy = Math.floor(langtonAnt.y * cellSize);
                        const antSize = Math.max(2, Math.floor(cellSize));
                        for (let py = antPy; py < antPy + antSize && py < availableSize; py++) {
                            for (let px = antPx; px < antPx + antSize && px < availableSize; px++) {
                                const idx = (py * Math.ceil(availableSize) + px) * 4;
                                data[idx] = 255;
                                data[idx + 1] = 50;
                                data[idx + 2] = 50;
                                data[idx + 3] = 255;
                            }
                        }
                        
                        ctx.putImageData(imageData, offsetX, offsetY);
                        
                        // Draw border
                        ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(offsetX, offsetY, availableSize, availableSize);
                        
                        // Step counter
                        ctx.fillStyle = 'rgba(150, 150, 150, 0.8)';
                        ctx.font = '12px Courier New';
                        ctx.fillText(`Steps: ${langtonSteps.toLocaleString()}`, offsetX, offsetY - 10);
                        
                    } else if (currentSurface === 'lorenz') {
                        // Special handling for Lorenz attractor
                        const points = generateLorenz(paramA, paramB, paramC);
                        const transformed = points.map(p => {
                            const rotated = rotatePoint(p, rotationX, rotationY);
                            return project(rotated);
                        });
                        
                        ctx.strokeStyle = 'rgba(200, 160, 60, 0.8)'; // vintage amber
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        transformed.forEach((p, i) => {
                            if (i === 0) ctx.moveTo(p[0], p[1]);
                            else ctx.lineTo(p[0], p[1]);
                        });
                        ctx.stroke();
                    } else {
                        // Generate surface mesh
                        const [uMin, uMax] = surface.uRange;
                        const [vMin, vMax] = surface.vRange;
                        const uStep = (uMax - uMin) / resolution;
                        const vStep = (vMax - vMin) / resolution;
                        
                        const points = [];
                        const edges = [];
                        
                        for (let ui = 0; ui <= resolution; ui++) {
                            for (let vi = 0; vi <= resolution; vi++) {
                                const u = uMin + ui * uStep;
                                const v = vMin + vi * vStep;
                                const p = surface.generate(u, v, paramA, paramB, paramC);
                                const rotated = rotatePoint(p, rotationX, rotationY);
                                points.push(project(rotated));
                                
                                // Create edges for wireframe
                                const idx = ui * (resolution + 1) + vi;
                                if (ui < resolution) {
                                    edges.push([idx, idx + resolution + 1]);
                                }
                                if (vi < resolution) {
                                    edges.push([idx, idx + 1]);
                                }
                            }
                        }
                        
                        // Draw wireframe
                        if (showWireframe) {
                            edges.forEach(([i, j]) => {
                                const p1 = points[i];
                                const p2 = points[j];
                                const avgZ = (p1[2] + p2[2]) / 2;
                                const alpha = Math.max(0.2, Math.min(0.9, 0.5 + avgZ * 0.3));
                                // Vintage amber/green color scheme
                                const hue = 45 + avgZ * 25; // amber to green range
                                ctx.strokeStyle = `hsla(${hue}, 70%, 50%, ${alpha})`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(p1[0], p1[1]);
                                ctx.lineTo(p2[0], p2[1]);
                                ctx.stroke();
                            });
                        }
                        
                        // Draw points
                        if (showPoints) {
                            points.forEach(p => {
                                const alpha = Math.max(0.4, Math.min(1, 0.6 + p[2] * 0.2));
                                ctx.fillStyle = `rgba(220, 180, 100, ${alpha})`; // vintage amber
                                ctx.beginPath();
                                ctx.arc(p[0], p[1], 2, 0, Math.PI * 2);
                                ctx.fill();
                            });
                        }
                    }
                    
                    // Auto rotation
                    if (autoRotate && !isDragging) {
                        rotationY += 0.005;
                    }
                    
                    requestAnimationFrame(render);
                }
                
                // Event listeners
                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    rotationY += (e.clientX - lastMouseX) * 0.01;
                    rotationX += (e.clientY - lastMouseY) * 0.01;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => isDragging = false);
                canvas.addEventListener('mouseleave', () => isDragging = false);
                
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    scale += e.deltaY > 0 ? -5 : 5;
                    scale = Math.max(20, Math.min(200, scale));
                }, { passive: false });
                
                // Control listeners
                document.getElementById('surfaceSelect').addEventListener('change', (e) => {
                    currentSurface = e.target.value;
                    document.getElementById('equations').innerHTML = surfaces[currentSurface].equations;
                    updateParamUI(currentSurface);
                    // Clear cache when surface changes
                    cachedBifurcation = null;
                    cachedArnold = null;
                    // Initialize Langton if selected
                    if (currentSurface === 'langton') {
                        initLangton(langtonGridSize);
                    }
                });
                
                document.getElementById('paramA').addEventListener('input', (e) => {
                    paramA = parseFloat(e.target.value);
                    document.getElementById('paramAVal').textContent = paramA.toFixed(1);
                    cachedBifurcation = null;
                    cachedArnold = null;
                    if (currentSurface === 'langton') {
                        langtonStepsPerFrame = Math.floor(paramA);
                        document.getElementById('paramAVal').textContent = langtonStepsPerFrame;
                    }
                });
                
                document.getElementById('paramB').addEventListener('input', (e) => {
                    paramB = parseFloat(e.target.value);
                    document.getElementById('paramBVal').textContent = paramB.toFixed(2);
                    cachedBifurcation = null;
                    if (currentSurface === 'langton') {
                        const newSize = Math.floor(paramB);
                        document.getElementById('paramBVal').textContent = newSize;
                        initLangton(newSize);
                    }
                });
                
                document.getElementById('paramC').addEventListener('input', (e) => {
                    paramC = parseFloat(e.target.value);
                    document.getElementById('paramCVal').textContent = paramC.toFixed(1);
                });
                
                document.getElementById('resolution').addEventListener('input', (e) => {
                    resolution = parseInt(e.target.value);
                    document.getElementById('resVal').textContent = resolution;
                });
                
                document.getElementById('showWireframe').addEventListener('change', (e) => {
                    showWireframe = e.target.checked;
                });
                
                document.getElementById('showPoints').addEventListener('change', (e) => {
                    showPoints = e.target.checked;
                });
                
                const resetBtn = document.getElementById('resetBtn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        if (currentSurface === 'langton') {
                            initLangton(langtonGridSize);
                        }
                    });
                }
                
                document.getElementById('autoRotate').addEventListener('change', (e) => {
                    autoRotate = e.target.checked;
                });
                
                render();
            }, 50);
        }

        // Brain simulator initialization function
        window.initializeBrainSimulator = function() {
            console.log('initializeBrainSimulator called!');
            
            setTimeout(() => {
                const canvas = document.getElementById('neuralCanvas');
                const ctx = canvas ? canvas.getContext('2d') : null;
                
                console.log('Brain simulator initializing...', canvas, ctx);
                
                if (!canvas || !ctx) {
                    console.error('Canvas not found - retrying in 100ms');
                    setTimeout(() => window.initializeBrainSimulator(), 100);
                    return;
                }
                
                console.log('Canvas found, setting up simulator');
                
                // Resize canvas to fit container
                function resizeCanvas() {
                    const container = canvas.parentElement;
                    if (container) {
                        canvas.width = container.clientWidth || 600;
                        canvas.height = container.clientHeight || 380;
                    }
                }
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                const neurons = [];
                const connections = [];
                let animationId;
                let neuronTypeMode = 'excitatory'; // Whether new neurons are E or I
                let neuronBehaviorMode = 'RS'; // Izhikevich type for new neurons
                let isDragging = false;
                let dragStart = null;
                let dragEnd = null;
                let selectedNeuron = null;

                // Izhikevich model parameters for different neuron types
                // Based on: Izhikevich, E.M. (2003) "Simple Model of Spiking Neurons"
                // IEEE Transactions on Neural Networks, 14:1569-1572
                const NEURON_TYPES = {
                    'RS': { a: 0.02, b: 0.2, c: -65, d: 8, name: 'Regular Spiking', desc: 'Typical cortical excitatory neuron' },
                    'IB': { a: 0.02, b: 0.2, c: -55, d: 4, name: 'Intrinsically Bursting', desc: 'Layer 5 pyramidal cells' },
                    'CH': { a: 0.02, b: 0.2, c: -50, d: 2, name: 'Chattering', desc: 'Fast rhythmic bursting' },
                    'FS': { a: 0.1, b: 0.2, c: -65, d: 2, name: 'Fast Spiking', desc: 'Typical inhibitory interneuron' },
                    'LTS': { a: 0.02, b: 0.25, c: -65, d: 2, name: 'Low-Threshold Spiking', desc: 'Low-threshold inhibitory' },
                    'RZ': { a: 0.1, b: 0.26, c: -65, d: 2, name: 'Resonator', desc: 'Subthreshold oscillations' }
                };

                // Connection class - strength determined by presynaptic neuron type
                class Connection {
                    constructor(from, to) {
                        this.from = from;
                        this.to = to;
                        this.weight = 1.0; // Base weight multiplier
                    }

                    // Get effective strength based on presynaptic neuron type
                    getStrength() {
                        const baseStrength = this.from.isExcitatory ? 12 : -15;
                        return baseStrength * this.weight * this.from.synapticWeight;
                    }

                    draw(ctx) {
                        const isExcitatory = this.from.isExcitatory;
                        const activity = Math.min(1, Math.abs(this.from.v + 65) / 100);
                        const alpha = activity * 0.6 + 0.3;
                        
                        if (isExcitatory) {
                            ctx.strokeStyle = `rgba(0, 200, 255, ${alpha})`;
                        } else {
                            ctx.strokeStyle = `rgba(255, 80, 80, ${alpha})`;
                        }
                        ctx.lineWidth = 1.5 + activity;
                        
                        const angle = Math.atan2(this.to.y - this.from.y, this.to.x - this.from.x);
                        const endX = this.to.x - Math.cos(angle) * 15;
                        const endY = this.to.y - Math.sin(angle) * 15;
                        
                        ctx.beginPath();
                        ctx.moveTo(this.from.x, this.from.y);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Arrow head
                        const headLen = 8;
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), 
                                  endY - headLen * Math.sin(angle - Math.PI / 6));
                        ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), 
                                  endY - headLen * Math.sin(angle + Math.PI / 6));
                        ctx.closePath();
                        ctx.fillStyle = ctx.strokeStyle;
                        ctx.fill();
                    }
                }

                // Izhikevich Neuron Model
                class Neuron {
                    constructor(x, y, behaviorType = 'RS') {
                        this.x = x;
                        this.y = y;
                        this.id = Math.random().toString(36).substr(2, 9);
                        
                        // Izhikevich model state variables
                        this.v = -65; // Membrane potential (mV)
                        this.u = -14; // Recovery variable
                        
                        // Set behavior type parameters
                        this.behaviorType = behaviorType;
                        const params = NEURON_TYPES[behaviorType];
                        this.a = params.a; // Time scale of recovery
                        this.b = params.b; // Sensitivity of recovery
                        this.c = params.c; // After-spike reset of v
                        this.d = params.d; // After-spike reset of u
                        
                        // Neuron properties
                        this.isExcitatory = true;
                        this.tonicInput = 0; // Tonic/basal input current
                        this.synapticInput = 0; // Accumulated synaptic input
                        this.synapticWeight = 1.0; // Output weight multiplier
                        
                        // Spike tracking
                        this.spikeHistory = [];
                        this.voltageTrace = new Array(400).fill(-65);
                        this.justSpiked = false;
                    }

                    setBehaviorType(type) {
                        if (NEURON_TYPES[type]) {
                            this.behaviorType = type;
                            const params = NEURON_TYPES[type];
                            this.a = params.a;
                            this.b = params.b;
                            this.c = params.c;
                            this.d = params.d;
                        }
                    }

                    // Receive synaptic input (positive = excitatory, negative = inhibitory)
                    receiveInput(amount) {
                        this.synapticInput += amount;
                    }

                    update(dt = 0.5) {
                        // Total input current
                        const I = this.tonicInput + this.synapticInput;
                        
                        // Decay synaptic input
                        this.synapticInput *= 0.8;
                        
                        this.justSpiked = false;
                        
                        // Izhikevich model equations (using Euler method with substeps)
                        // v' = 0.04v² + 5v + 140 - u + I
                        // u' = a(bv - u)
                        const steps = 2;
                        const h = dt / steps;
                        
                        for (let i = 0; i < steps; i++) {
                            if (this.v >= 30) {
                                // Spike!
                                this.v = this.c;
                                this.u = this.u + this.d;
                                this.justSpiked = true;
                                this.recordSpike(Date.now());
                            }
                            
                            const dv = (0.04 * this.v * this.v + 5 * this.v + 140 - this.u + I) * h;
                            const du = (this.a * (this.b * this.v - this.u)) * h;
                            
                            this.v += dv;
                            this.u += du;
                            
                            // Clamp voltage
                            this.v = Math.min(35, Math.max(-90, this.v));
                        }
                        
                        // Record voltage for trace
                        this.voltageTrace.shift();
                        this.voltageTrace.push(this.v);
                        
                        return this.justSpiked;
                    }

                    recordSpike(time) {
                        this.spikeHistory.push(time);
                        const cutoff = time - 2000;
                        this.spikeHistory = this.spikeHistory.filter(t => t > cutoff);
                    }

                    getFiringRate() {
                        const currentTime = Date.now();
                        const recentSpikes = this.spikeHistory.filter(t => t > currentTime - 1000);
                        return recentSpikes.length;
                    }

                    // Manual stimulation (e.g., click)
                    stimulate(amount = 15) {
                        this.synapticInput += amount;
                    }

                    draw(ctx) {
                        const radius = 14;
                        
                        // Color based on membrane potential
                        let color;
                        const vNorm = (this.v + 65) / 95; // Normalize from [-65, 30] to [0, 1]
                        
                        if (this.v > 0) {
                            // Spiking - bright yellow
                            color = 'rgba(255, 255, 100, 1)';
                        } else if (this.v > -50) {
                            // Depolarized
                            const intensity = (this.v + 50) / 50;
                            color = `rgba(255, 255, ${100 + 155 * (1 - intensity)}, ${0.5 + intensity * 0.5})`;
                        } else {
                            // Resting or hyperpolarized
                            color = this.isExcitatory ? 'rgba(100, 180, 255, 0.8)' : 'rgba(255, 100, 100, 0.8)';
                        }

                        // Draw neuron body
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Border
                        ctx.strokeStyle = this.isExcitatory ? '#4a9eff' : '#ff4a4a';
                        ctx.lineWidth = 3;
                        ctx.stroke();

                        // Tonic input indicator (yellow dot)
                        if (this.tonicInput > 0) {
                            const dotSize = 3 + (this.tonicInput / 20) * 4;
                            ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, dotSize, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // E/I label
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.isExcitatory ? 'E' : 'I', this.x, this.y);
                        
                        // Behavior type label
                        ctx.font = '8px Arial';
                        ctx.fillStyle = '#ccc';
                        ctx.fillText(this.behaviorType, this.x, this.y + radius + 8);
                    }
                }

                // Propagate spike to connected neurons
                function propagateSpike(neuron) {
                    const outgoing = connections.filter(c => c.from === neuron);
                    outgoing.forEach(conn => {
                        // Synaptic delay (1-5ms simulated)
                        setTimeout(() => {
                            const strength = conn.getStrength();
                            conn.to.receiveInput(strength);
                        }, Math.random() * 4 + 1);
                    });
                }

                function animate() {
                    if (!ctx) return;
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Update all neurons
                    neurons.forEach(neuron => {
                        const spiked = neuron.update();
                        if (spiked) {
                            propagateSpike(neuron);
                        }
                    });

                    // Draw connections first (behind neurons)
                    connections.forEach(conn => conn.draw(ctx));
                    
                    // Draw neurons
                    neurons.forEach(neuron => neuron.draw(ctx));

                    // Draw connection being made
                    if (isDragging && dragStart && dragEnd) {
                        const isExcit = dragStart.isExcitatory;
                        ctx.strokeStyle = isExcit ? 'rgba(0, 200, 255, 0.5)' : 'rgba(255, 80, 80, 0.5)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(dragStart.x, dragStart.y);
                        ctx.lineTo(dragEnd.x, dragEnd.y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    animationId = requestAnimationFrame(animate);
                }

                // View mode: 'combined' or 'individual'
                let viewMode = 'combined';
                
                // Color palette for neurons in combined view
                const neuronColors = [
                    '#00aaff', '#ff6666', '#44ff44', '#ffaa00', '#aa44ff', 
                    '#ff44aa', '#44ffff', '#ffff44', '#ff8844', '#44ff88',
                    '#8844ff', '#ff4488', '#88ff44', '#4488ff', '#ff8888'
                ];

                function updateCombinedRecording() {
                    const combCanvas = document.getElementById('combinedCanvas');
                    const legendContainer = document.getElementById('combinedLegend');
                    if (!combCanvas || !legendContainer) return;
                    
                    // Resize canvas to match container
                    const container = combCanvas.parentElement;
                    if (container) {
                        combCanvas.width = container.clientWidth || 300;
                        combCanvas.height = container.clientHeight - 30 || 250;
                    }
                    
                    const combCtx = combCanvas.getContext('2d');
                    const width = combCanvas.width;
                    const height = combCanvas.height;
                    
                    // Clear
                    combCtx.fillStyle = '#000';
                    combCtx.fillRect(0, 0, width, height);
                    
                    if (neurons.length === 0) {
                        combCtx.fillStyle = '#555';
                        combCtx.font = '14px Courier New';
                        combCtx.textAlign = 'center';
                        combCtx.fillText('Place neurons to see membrane potential traces', width / 2, height / 2);
                        legendContainer.innerHTML = '';
                        return;
                    }
                    
                    // Draw reference lines
                    combCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                    combCtx.lineWidth = 1;
                    combCtx.setLineDash([5, 5]);
                    
                    // -65mV resting line
                    const restY = height - ((-65 + 90) / 125) * height;
                    combCtx.beginPath();
                    combCtx.moveTo(0, restY);
                    combCtx.lineTo(width, restY);
                    combCtx.stroke();
                    
                    // 0mV line
                    const zeroY = height - ((0 + 90) / 125) * height;
                    combCtx.beginPath();
                    combCtx.moveTo(0, zeroY);
                    combCtx.lineTo(width, zeroY);
                    combCtx.stroke();
                    
                    // -40mV threshold line
                    const threshY = height - ((-40 + 90) / 125) * height;
                    combCtx.beginPath();
                    combCtx.moveTo(0, threshY);
                    combCtx.lineTo(width, threshY);
                    combCtx.stroke();
                    combCtx.setLineDash([]);
                    
                    // Y-axis labels
                    combCtx.fillStyle = '#666';
                    combCtx.font = '10px Courier New';
                    combCtx.textAlign = 'right';
                    combCtx.fillText('0mV', 35, zeroY + 3);
                    combCtx.fillText('-40mV', 35, threshY + 3);
                    combCtx.fillText('-65mV', 35, restY + 3);
                    
                    // Draw each neuron's trace
                    const xScale = (width - 40) / 400; // Scale trace to canvas width
                    
                    neurons.forEach((neuron, idx) => {
                        const color = neuronColors[idx % neuronColors.length];
                        combCtx.strokeStyle = color;
                        combCtx.lineWidth = 1.5;
                        combCtx.beginPath();
                        
                        neuron.voltageTrace.forEach((v, i) => {
                            const x = 40 + i * xScale;
                            const y = height - ((v + 90) / 125) * height;
                            if (i === 0) combCtx.moveTo(x, y);
                            else combCtx.lineTo(x, y);
                        });
                        
                        combCtx.stroke();
                    });
                    
                    // Update legend
                    legendContainer.innerHTML = neurons.map((neuron, idx) => {
                        const color = neuronColors[idx % neuronColors.length];
                        const typeLabel = neuron.isExcitatory ? 'E' : 'I';
                        const rate = neuron.getFiringRate();
                        return `<div class="combined-legend-item">
                            <span class="combined-legend-color" style="background:${color}"></span>
                            N${idx + 1} (${typeLabel}, ${neuron.behaviorType}) ${rate}Hz
                        </div>`;
                    }).join('');
                }

                function updateIndividualRecordings() {
                    const container = document.getElementById('recordingsContainer');
                    if (!container) return;
                    container.innerHTML = '';
                    
                    neurons.forEach((neuron, idx) => {
                        const plotDiv = document.createElement('div');
                        plotDiv.className = 'recording-plot';
                        
                        const title = document.createElement('h4');
                        const typeLabel = neuron.isExcitatory ? 'E' : 'I';
                        const color = neuronColors[idx % neuronColors.length];
                        title.innerHTML = `<span style="color:${color}">●</span> N${idx + 1} (${typeLabel}, ${neuron.behaviorType})`;
                        
                        const recCanvas = document.createElement('canvas');
                        recCanvas.width = 280;
                        recCanvas.height = 60;
                        
                        const info = document.createElement('div');
                        info.className = 'recording-info';
                        const firingRate = neuron.getFiringRate();
                        const typeName = NEURON_TYPES[neuron.behaviorType].name;
                        info.textContent = `${firingRate} Hz | ${typeName} | I=${neuron.tonicInput.toFixed(1)}pA`;
                        
                        plotDiv.appendChild(title);
                        plotDiv.appendChild(recCanvas);
                        plotDiv.appendChild(info);
                        container.appendChild(plotDiv);
                        
                        const recCtx = recCanvas.getContext('2d');
                        recCtx.fillStyle = '#000';
                        recCtx.fillRect(0, 0, recCanvas.width, recCanvas.height);
                        
                        // Draw voltage trace (color already defined above)
                        recCtx.strokeStyle = color;
                        recCtx.lineWidth = 1.5;
                        recCtx.beginPath();
                        
                        neuron.voltageTrace.forEach((v, i) => {
                            const x = i;
                            const y = recCanvas.height - ((v + 90) / 125) * recCanvas.height;
                            if (i === 0) recCtx.moveTo(x, y);
                            else recCtx.lineTo(x, y);
                        });
                        
                        recCtx.stroke();
                        
                        // Reference lines
                        recCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                        recCtx.lineWidth = 0.5;
                        recCtx.setLineDash([2, 2]);
                        
                        const restY = recCanvas.height - ((-65 + 90) / 125) * recCanvas.height;
                        recCtx.beginPath();
                        recCtx.moveTo(0, restY);
                        recCtx.lineTo(recCanvas.width, restY);
                        recCtx.stroke();
                        recCtx.setLineDash([]);
                    });
                }

                function updateRecordings() {
                    if (viewMode === 'combined') {
                        updateCombinedRecording();
                    } else {
                        updateIndividualRecordings();
                    }
                }

                function updateRasterPlot() {
                    const rasterCanvas = document.getElementById('rasterCanvas');
                    const rasterLegend = document.getElementById('rasterLegend');
                    if (!rasterCanvas || !rasterLegend) return;
                    
                    const ctx = rasterCanvas.getContext('2d');
                    const width = rasterCanvas.width;
                    const height = rasterCanvas.height;
                    
                    // Clear
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);
                    
                    if (neurons.length === 0) {
                        ctx.fillStyle = '#444';
                        ctx.font = '11px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText('No neurons', width / 2, height / 2);
                        rasterLegend.innerHTML = '';
                        return;
                    }
                    
                    const currentTime = Date.now();
                    const timeWindow = 3000; // 3 seconds
                    const rowHeight = Math.min(20, (height - 20) / neurons.length);
                    const startY = 10;
                    
                    // Draw time axis
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, height - 1);
                    ctx.lineTo(width, height - 1);
                    ctx.stroke();
                    
                    // Time labels
                    ctx.fillStyle = '#555';
                    ctx.font = '8px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('-3s', 10, height - 3);
                    ctx.fillText('now', width - 15, height - 3);
                    
                    // Draw spikes for each neuron
                    neurons.forEach((neuron, idx) => {
                        const color = neuronColors[idx % neuronColors.length];
                        const y = startY + idx * rowHeight + rowHeight / 2;
                        
                        // Draw row background line
                        ctx.strokeStyle = '#222';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                        
                        // Draw spikes
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2;
                        
                        neuron.spikeHistory.forEach(spikeTime => {
                            const age = currentTime - spikeTime;
                            if (age < timeWindow) {
                                const x = width - (age / timeWindow) * width;
                                ctx.beginPath();
                                ctx.moveTo(x, y - rowHeight / 3);
                                ctx.lineTo(x, y + rowHeight / 3);
                                ctx.stroke();
                            }
                        });
                    });
                    
                    // Update legend
                    rasterLegend.innerHTML = neurons.map((neuron, idx) => {
                        const color = neuronColors[idx % neuronColors.length];
                        const typeLabel = neuron.isExcitatory ? 'E' : 'I';
                        return `<span class="raster-legend-item">
                            <span class="raster-legend-color" style="background:${color}"></span>
                            N${idx + 1}
                        </span>`;
                    }).join('');
                }

                let recordingInterval = null;
                let rasterInterval = null;
                
                // View toggle handlers
                const viewCombinedBtn = document.getElementById('viewCombinedBtn');
                const viewIndividualBtn = document.getElementById('viewIndividualBtn');
                const combinedRecording = document.getElementById('combinedRecording');
                const recordingsContainer = document.getElementById('recordingsContainer');
                
                if (viewCombinedBtn) {
                    viewCombinedBtn.addEventListener('click', () => {
                        viewMode = 'combined';
                        viewCombinedBtn.classList.add('active');
                        viewIndividualBtn.classList.remove('active');
                        combinedRecording.style.display = 'block';
                        recordingsContainer.classList.add('hidden');
                    });
                }
                
                if (viewIndividualBtn) {
                    viewIndividualBtn.addEventListener('click', () => {
                        viewMode = 'individual';
                        viewIndividualBtn.classList.add('active');
                        viewCombinedBtn.classList.remove('active');
                        combinedRecording.style.display = 'none';
                        recordingsContainer.classList.remove('hidden');
                    });
                }

                function getNeuronAt(x, y) {
                    return neurons.find(n => {
                        const dist = Math.hypot(n.x - x, n.y - y);
                        return dist < 18;
                    });
                }

                // Update panel to show neuron properties
                function updatePanel(neuron) {
                    const typeLabel = document.getElementById('neuronTypeLabel');
                    typeLabel.textContent = neuron.isExcitatory ? 'Excitatory' : 'Inhibitory';
                    typeLabel.className = 'neuron-type-indicator ' + (neuron.isExcitatory ? 'excitatory' : 'inhibitory');
                    
                    document.getElementById('panelBehaviorSelect').value = neuron.behaviorType;
                    document.getElementById('behaviorDescription').textContent = NEURON_TYPES[neuron.behaviorType].desc;
                    
                    document.getElementById('basalRateSlider').value = neuron.tonicInput;
                    document.getElementById('rateValue').textContent = neuron.tonicInput.toFixed(1);
                    
                    document.getElementById('weightSlider').value = neuron.synapticWeight;
                    document.getElementById('weightValue').textContent = neuron.synapticWeight.toFixed(1);
                }

                canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const neuron = getNeuronAt(x, y);
                    
                    if (neuron) {
                        isDragging = true;
                        dragStart = neuron;
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (isDragging) {
                        const rect = canvas.getBoundingClientRect();
                        dragEnd = {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top
                        };
                    }
                });

                canvas.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (isDragging) {
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        const targetNeuron = getNeuronAt(x, y);
                        
                        if (targetNeuron && targetNeuron !== dragStart) {
                            const existing = connections.find(c => c.from === dragStart && c.to === targetNeuron);
                            if (!existing) {
                                // Connection type is determined by presynaptic neuron!
                                connections.push(new Connection(dragStart, targetNeuron));
                            }
                        }
                        
                        isDragging = false;
                        dragStart = null;
                        dragEnd = null;
                    }
                });

                canvas.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (isDragging) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const neuron = getNeuronAt(x, y);
                    
                    if (neuron) {
                        // Stimulate existing neuron
                        neuron.stimulate(20);
                    } else {
                        // Create new neuron with current settings
                        const newNeuron = new Neuron(x, y, neuronBehaviorMode);
                        newNeuron.isExcitatory = (neuronTypeMode === 'excitatory');
                        neurons.push(newNeuron);
                    }
                });

                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const neuron = getNeuronAt(x, y);
                    if (neuron) {
                        selectedNeuron = neuron;
                        const panel = document.getElementById('neuronPanel');
                        
                        // Position panel
                        let panelX = e.clientX + 10;
                        let panelY = e.clientY + 10;
                        if (panelX + 280 > window.innerWidth) panelX = e.clientX - 290;
                        if (panelY + 400 > window.innerHeight) panelY = e.clientY - 410;
                        
                        panel.style.left = panelX + 'px';
                        panel.style.top = panelY + 'px';
                        panel.classList.add('visible');
                        
                        updatePanel(neuron);
                    }
                });

                canvas.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const neuron = getNeuronAt(x, y);
                    if (neuron) {
                        neuron.isExcitatory = !neuron.isExcitatory;
                    }
                });

                // Control button handlers
                document.getElementById('clearBtn').addEventListener('click', () => {
                    neurons.length = 0;
                    connections.length = 0;
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    document.getElementById('neuronPanel').classList.remove('visible');
                    selectedNeuron = null;
                });

                document.getElementById('exciteBtn').addEventListener('click', () => {
                    neuronTypeMode = 'excitatory';
                    document.getElementById('exciteBtn').classList.add('active');
                    document.getElementById('inhibitBtn').classList.remove('active');
                });

                document.getElementById('inhibitBtn').addEventListener('click', () => {
                    neuronTypeMode = 'inhibitory';
                    document.getElementById('inhibitBtn').classList.add('active');
                    document.getElementById('exciteBtn').classList.remove('active');
                });

                document.getElementById('neuronBehaviorSelect').addEventListener('change', (e) => {
                    neuronBehaviorMode = e.target.value;
                });

                // Panel controls
                document.getElementById('toggleTypeBtn').addEventListener('click', () => {
                    if (selectedNeuron) {
                        selectedNeuron.isExcitatory = !selectedNeuron.isExcitatory;
                        updatePanel(selectedNeuron);
                    }
                });

                document.getElementById('panelBehaviorSelect').addEventListener('change', (e) => {
                    if (selectedNeuron) {
                        selectedNeuron.setBehaviorType(e.target.value);
                        document.getElementById('behaviorDescription').textContent = 
                            NEURON_TYPES[e.target.value].desc;
                    }
                });

                document.getElementById('basalRateSlider').addEventListener('input', (e) => {
                    if (selectedNeuron) {
                        selectedNeuron.tonicInput = parseFloat(e.target.value);
                        document.getElementById('rateValue').textContent = selectedNeuron.tonicInput.toFixed(1);
                    }
                });

                document.getElementById('weightSlider').addEventListener('input', (e) => {
                    if (selectedNeuron) {
                        selectedNeuron.synapticWeight = parseFloat(e.target.value);
                        document.getElementById('weightValue').textContent = selectedNeuron.synapticWeight.toFixed(1);
                    }
                });

                document.getElementById('deleteNeuronBtn').addEventListener('click', () => {
                    if (selectedNeuron) {
                        // Remove all connections involving this neuron
                        for (let i = connections.length - 1; i >= 0; i--) {
                            if (connections[i].from === selectedNeuron || connections[i].to === selectedNeuron) {
                                connections.splice(i, 1);
                            }
                        }
                        // Remove neuron
                        const idx = neurons.indexOf(selectedNeuron);
                        if (idx > -1) neurons.splice(idx, 1);
                        
                        document.getElementById('neuronPanel').classList.remove('visible');
                        selectedNeuron = null;
                    }
                });

                document.getElementById('closePanel').addEventListener('click', () => {
                    document.getElementById('neuronPanel').classList.remove('visible');
                    selectedNeuron = null;
                });

                document.addEventListener('click', (e) => {
                    const panel = document.getElementById('neuronPanel');
                    if (panel && !panel.contains(e.target) && e.target !== canvas) {
                        panel.classList.remove('visible');
                        selectedNeuron = null;
                    }
                });

                if (canvas && ctx) {
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Add default neurons
                    const neuron1 = new Neuron(150, 170);
                    neuron1.isExcitatory = true;
                    neuron1.setBehaviorType('CH'); // Chattering - high spiking
                    neuron1.tonicInput = 8; // Give it tonic input to make it spike
                    neurons.push(neuron1);
                    
                    const neuron2 = new Neuron(300, 170);
                    neuron2.isExcitatory = true;
                    neuron2.setBehaviorType('RS'); // Regular spiking
                    neurons.push(neuron2);
                    
                    const neuron3 = new Neuron(450, 170);
                    neuron3.isExcitatory = false;
                    neuron3.setBehaviorType('FS'); // Fast spiking inhibitory
                    neurons.push(neuron3);
                    
                    // Connect them: 1 -> 2 -> 3
                    connections.push(new Connection(neuron1, neuron2));
                    connections.push(new Connection(neuron2, neuron3));
                    
                    // Start the recording and raster update intervals
                    recordingInterval = setInterval(updateRecordings, 100);
                    rasterInterval = setInterval(updateRasterPlot, 50);
                    
                    animate();
                    
                    // Store cleanup function for when leaving the page
                    window.brainSimulatorCleanup = () => {
                        if (animationId) {
                            cancelAnimationFrame(animationId);
                            animationId = null;
                        }
                        clearInterval(recordingInterval);
                        clearInterval(rasterInterval);
                        neurons.length = 0;
                        connections.length = 0;
                    };
                }
                
            }, 50);
        };

        // Globe initializer
        const initializeGlobe = function() {
            setTimeout(() => {
                const canvas = document.getElementById('globeCanvas');
                if (!canvas) {
                    console.error('Globe canvas not found');
                    return;
                }
                
                // Use full window dimensions
                let width = window.innerWidth;
                let height = window.innerHeight;
                canvas.width = width;
                canvas.height = height;
                
                console.log('Globe canvas dimensions:', width, height);
                
                // Load Three.js dynamically
                function loadThreeJS(callback) {
                    if (window.THREE && window.THREE.OrbitControls) {
                        console.log('Three.js already loaded');
                        callback();
                        return;
                    }
                    if (window.THREE) {
                        // Three.js loaded but not OrbitControls
                        console.log('Loading OrbitControls...');
                        const controlsScript = document.createElement('script');
                        controlsScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js';
                        controlsScript.onload = callback;
                        document.head.appendChild(controlsScript);
                        return;
                    }
                    console.log('Loading Three.js...');
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                    script.onload = () => {
                        console.log('Three.js loaded, loading OrbitControls...');
                        // Load OrbitControls
                        const controlsScript = document.createElement('script');
                        controlsScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js';
                        controlsScript.onload = () => {
                            console.log('OrbitControls loaded');
                            callback();
                        };
                        document.head.appendChild(controlsScript);
                    };
                    document.head.appendChild(script);
                }
                
                loadThreeJS(() => initGlobeScene());
                
                function initGlobeScene() {
                console.log('Initializing globe scene...');
                // Three.js setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000011);
                
                const camera = new THREE.PerspectiveCamera(45, canvas.width / canvas.height, 0.1, 1000);
                camera.position.z = 3;
                
                const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(canvas.width, canvas.height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Orbit controls
                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 1.5;
                controls.maxDistance = 10;
                controls.enablePan = false;
                
                // Create Earth - high resolution sphere
                const geometry = new THREE.SphereGeometry(1, 128, 128);
                
                // Load high-res texture from NASA Blue Marble
                const textureLoader = new THREE.TextureLoader();
                const earthTexture = textureLoader.load(
                    'https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg',
                    (texture) => { 
                        console.log('Earth texture loaded');
                        // Enable anisotropic filtering for better quality at angles
                        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        renderer.render(scene, camera); 
                    },
                    undefined,
                    (err) => { console.error('Texture load error:', err); }
                );
                
                const material = new THREE.MeshPhongMaterial({
                    map: earthTexture,
                    bumpScale: 0.05,
                    shininess: 5,
                });
                
                const earth = new THREE.Mesh(geometry, material);
                scene.add(earth);
                
                // Add atmosphere glow
                const atmosphereGeom = new THREE.SphereGeometry(1.02, 64, 64);
                const atmosphereMat = new THREE.MeshBasicMaterial({
                    color: 0x4488ff,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                const atmosphere = new THREE.Mesh(atmosphereGeom, atmosphereMat);
                scene.add(atmosphere);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x333333);
                scene.add(ambientLight);
                
                const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
                sunLight.position.set(5, 3, 5);
                scene.add(sunLight);
                
                // Stars background
                const starsGeometry = new THREE.BufferGeometry();
                const starPositions = [];
                for (let i = 0; i < 2000; i++) {
                    const r = 100;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    starPositions.push(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                }
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
                const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
                const stars = new THREE.Points(starsGeometry, starsMaterial);
                scene.add(stars);
                
                // Predefined pins - add your locations here
                const pins = [
                    { title: "Boston, Massachusetts", note: "Home (for now)", lat: 42.3601, lng: -71.0589 },
                    { title: "Chapel Hill, NC", note: "Birthplace", lat: 35.9132, lng: -79.0558 },
                    { title: "Hershey, PA", note: "High School", lat: 40.2854, lng: -76.6505 },
                    { title: "Black Rock City, NV", note: "Burning Man 2x", lat: 40.7864, lng: -119.2065 },
                    { title: "Landmannalaugar, Iceland", note: "Beautiful painted mountains", lat: 63.9930, lng: -19.0617 },
                    { title: "Lake Como, Italy", note: "Nice place", lat: 46.0160, lng: 9.2572 },
                    { title: "San Jose, Costa Rica", note: "Volcanic sand and rainforests with monkeys", lat: 9.9281, lng: -84.0907 },
                    { title: "Madrid, Spain", note: "Cured meats and fast trains", lat: 40.4168, lng: -3.7038 },
                    { title: "Rovinj, Croatia", note: "Clear and harmless jelly fish", lat: 45.0812, lng: 13.6387 }
                ];
                
                const pinMeshes = [];
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                // Convert lat/lng to 3D position
                function latLngToVector3(lat, lng, radius = 1.01) {
                    const phi = (90 - lat) * (Math.PI / 180);
                    const theta = (lng + 180) * (Math.PI / 180);
                    return new THREE.Vector3(
                        -radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.cos(phi),
                        radius * Math.sin(phi) * Math.sin(theta)
                    );
                }
                
                // Create pin mesh - teardrop/pin shape
                function createPinMesh(lat, lng, color = 0xff3333) {
                    const group = new THREE.Group();
                    
                    // Pin head (small sphere) - on top, away from globe
                    const headGeom = new THREE.SphereGeometry(0.012, 12, 12);
                    const headMat = new THREE.MeshBasicMaterial({ color: color });
                    const head = new THREE.Mesh(headGeom, headMat);
                    head.position.y = 0.025;
                    
                    // Pin stem (thin cone pointing down into globe)
                    const stemGeom = new THREE.ConeGeometry(0.004, 0.025, 8);
                    const stemMat = new THREE.MeshBasicMaterial({ color: 0xcccccc });
                    const stem = new THREE.Mesh(stemGeom, stemMat);
                    stem.position.y = 0.0125;
                    
                    group.add(head);
                    group.add(stem);
                    
                    // Position and orient the pin - pointing outward from globe center
                    const pos = latLngToVector3(lat, lng, 1.0);
                    group.position.copy(pos);
                    group.lookAt(new THREE.Vector3(0, 0, 0));
                    group.rotateX(-Math.PI / 2);
                    
                    return group;
                }
                
                // Create all pins
                function renderPins() {
                    pins.forEach((pin, i) => {
                        const mesh = createPinMesh(pin.lat, pin.lng, 0xff4444);
                        scene.add(mesh);
                        pinMeshes.push({ mesh, data: pin });
                    });
                }
                
                // Show pin modal
                function showPinModal(pin) {
                    const modal = document.getElementById('pinModal');
                    if (modal) {
                        document.getElementById('modalTitle').textContent = pin.title;
                        document.getElementById('modalNote').textContent = pin.note;
                        modal.classList.add('visible');
                    }
                }
                
                // Close modal
                const closeBtn = document.getElementById('closeModal');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        document.getElementById('pinModal').classList.remove('visible');
                    });
                }
                
                // Click handler for pins
                canvas.addEventListener('click', (event) => {
                    const rect = canvas.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    
                    // Check if clicked on a pin
                    const allPinMeshes = pinMeshes.flatMap(pm => pm.mesh.children);
                    const pinIntersects = raycaster.intersectObjects(allPinMeshes);
                    if (pinIntersects.length > 0) {
                        const clickedMesh = pinIntersects[0].object.parent;
                        const pinData = pinMeshes.find(pm => pm.mesh === clickedMesh);
                        if (pinData) {
                            showPinModal(pinData.data);
                        }
                    }
                });
                
                // Close modal on background click
                const pinModal = document.getElementById('pinModal');
                if (pinModal) {
                    pinModal.addEventListener('click', (e) => {
                        if (e.target.id === 'pinModal') {
                            e.target.classList.remove('visible');
                        }
                    });
                }
                
                // Render pins
                renderPins();
                
                // Handle resize - use full window
                function onResize() {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    canvas.width = w;
                    canvas.height = h;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                }
                window.addEventListener('resize', onResize);
                // Call resize immediately to ensure proper sizing
                onResize();
                
                // Animation loop
                let animationId;
                function animate() {
                    animationId = requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                }
                console.log('Starting globe animation');
                animate();
                
                // Cleanup on tab change
                const originalLoadTab = window.loadTabCleanup || (() => {});
                window.loadTabCleanup = () => {
                    if (animationId) cancelAnimationFrame(animationId);
                    originalLoadTab();
                };
                
                } // end initGlobeScene
            }, 100);
        };

        // Load intro tab by default
        console.log('Setting up DOMContentLoaded listener...');
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded fired!');
            loadTab('intro');
        });
    </script>
</body>
</html>
