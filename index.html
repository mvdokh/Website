<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Martin Dokholyan</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      font-family: Arial, sans-serif;
      color: white;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
    }

    .content {
      position: relative;
      z-index: 1;
      padding: 40px;
    }

    table {
      background-color: rgba(0, 0, 0, 0.6);
      border-radius: 15px;
      padding: 20px;
    }

    a {
      color: #aad;
    }
  </style>
</head>
<body>
  <canvas id="shaderCanvas"></canvas>

  <div class="content">
    <table>
      <tr>
        <td width="250">
          <img src="unnamed.jpg" width="240" style="border-radius: 10px;">
        </td>
        <td>
          <h1>Martin Dokholyan</h1>
          <p>Biochemistry & Molecular Biology major at Boston University.</p>
          <p>
            <a href="https://www.linkedin.com/in/mvdokh/">
              <img src="https://img.shields.io/badge/LinkedIn-mvdokh-blue?style=flat&logo=linkedin" alt="LinkedIn">
            </a>
            <br>
            <a href="https://github.com/mvdokh">
              <img src="https://img.shields.io/badge/GitHub-mvdokh-black?style=flat&logo=github" alt="GitHub">
            </a>
          </p>
        </td>
      </tr>
    </table>

    <hr>

    <h3>About Me</h3>
    <p>Interested in the neural basis of behavior and active sensing.</p>
    <p>üìç Allston, MA<br>üéì BMB @ BU 2026</p>
  </div>

  <!-- Shader from https://www.shadertoy.com/view/w3KGRK -->
  <script type="x-shader/x-fragment" id="fragShader">
    precision mediump float;
    uniform float iTime;
    uniform vec2 iResolution;

    float hash(vec2 p) {
      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
    }

    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(a, b, u.x) +
             (c - a) * u.y * (1.0 - u.x) +
             (d - b) * u.x * u.y;
    }

    void mainImage(out vec4 fragColor, in vec2 fragCoord) {
      vec2 uv = fragCoord / iResolution.xy;
      vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));
      float n = noise(uv * 10.0 + iTime * 0.1);
      col *= n;
      fragColor = vec4(col, 1.0);
    }

    void main() {
      mainImage(gl_FragColor, gl_FragCoord.xy);
    }
  </script>

  <script>
    const canvas = document.getElementById('shaderCanvas');
    const gl = canvas.getContext('webgl');
    let time = 0;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }

    window.addEventListener('resize', resize);
    resize();

    function compileShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = compileShader(gl.VERTEX_SHADER, `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `);

    const fragSource = document.getElementById('fragShader').text;
    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragSource);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    const positionLocation = gl.getAttribLocation(program, "position");
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1,
      1, -1,
      -1, 1,
      -1, 1,
      1, -1,
      1, 1
    ]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    const iTimeLoc = gl.getUniformLocation(program, "iTime");
    const iResLoc = gl.getUniformLocation(program, "iResolution");

    function render() {
      time += 0.016;
      gl.uniform1f(iTimeLoc, time);
      gl.uniform2f(iResLoc, canvas.width, canvas.height);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }

    render();
  </script>
</body>
</html>
