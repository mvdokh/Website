<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Martin Dokholyan</title>

<!-- Pixel font - classic blocky style -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />

<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: black;
    overflow: hidden;
    font-family: 'Press Start 2P', monospace;
    color: white;
    user-select: none;
  }
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 40px;
  }

  canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    image-rendering: pixelated;
    z-index: 0;
  }

  #content-wrapper {
    position: relative;
    z-index: 10;
    display: flex;
    background: rgba(0,0,0,0.8);
    border: 4px solid white;
    border-radius: 6px;
    padding: 30px;
    max-width: 850px;
    gap: 40px;
  }

  #photo {
    width: 200px;
    height: 200px;
    border: 3px solid white;
    border-radius: 4px;
    background: #111;
    overflow: hidden;
    image-rendering: pixelated;
  }
  #photo img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    image-rendering: pixelated;
    display: block;
  }

  #text-block {
    max-width: 600px;
    white-space: pre-wrap;
    font-size: 1rem;
    line-height: 1.4;
  }

  #name {
    font-size: 2.5rem;
    margin-bottom: 20px;
    user-select: text;
  }
</style>
</head>
<body>

<canvas id="bgcanvas"></canvas>

<div id="content-wrapper" role="main" aria-label="Profile information">
  <div id="photo">
    <img src="unnamed.jpg" alt="Martin Dokholyan" />
  </div>
  <div id="text-block">
    <div id="name">MARTIN DOKHOLYAN</div>
    Biochemistry & Molecular Biology major at Boston University.
    Interested in the neural basis of behavior and active sensing.
    üìç Allston, MA
    üéì BMB @ BU 2026
  </div>
</div>

<script>
  // Setup WebGL for simple pixelated b&w moving pattern background
  const canvas = document.getElementById('bgcanvas');
  const gl = canvas.getContext('webgl');
  if (!gl) alert('WebGL not supported');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  window.addEventListener('resize', resize);
  resize();

  const vertexSource = `
    attribute vec2 aPosition;
    void main() {
      gl_Position = vec4(aPosition, 0, 1);
    }
  `;

  // Simple pixel grid that shifts diagonally over time in black & white
  const fragmentSource = `
    precision mediump float;
    uniform vec2 iResolution;
    uniform float iTime;

    void main() {
      vec2 uv = gl_FragCoord.xy / iResolution.xy;
      uv *= 50.0;  // grid scale (more pixels)
      uv += vec2(iTime * 2.0, iTime * 2.0); // diagonal scroll

      // get cell coordinates
      vec2 cell = floor(uv);
      float checker = mod(cell.x + cell.y, 2.0);

      // make sharp black & white checker
      float color = step(0.5, checker);

      // convert to vec3 white or black
      vec3 finalColor = vec3(color);

      gl_FragColor = vec4(finalColor, 1.0);
    }
  `;

  function createShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  }

  function createProgram(vsSource, fsSource) {
    const vertexShader = createShader(gl.VERTEX_SHADER, vsSource);
    const fragmentShader = createShader(gl.FRAGMENT_SHADER, fsSource);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(program));
      return null;
    }
    return program;
  }

  const program = createProgram(vertexSource, fragmentSource);
  gl.useProgram(program);

  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
     1,  1
  ]), gl.STATIC_DRAW);

  const positionLocation = gl.getAttribLocation(program, 'aPosition');
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  const iResolutionLoc = gl.getUniformLocation(program, 'iResolution');
  const iTimeLoc = gl.getUniformLocation(program, 'iTime');

  let startTime = performance.now();

  function render() {
    resize();
    const currentTime = (performance.now() - startTime) / 1000;
    gl.uniform2f(iResolutionLoc, canvas.width, canvas.height);
    gl.uniform1f(iTimeLoc, currentTime);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
  }
  render();
</script>

</body>
</html>
