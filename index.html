<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shader Test</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%; overflow: hidden;
    background: black;
  }
  canvas {
    display: block; /* removes scrollbars */
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
  }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script>
  const canvas = document.getElementById('glcanvas');
  const gl = canvas.getContext('webgl');

  if (!gl) {
    alert('WebGL not supported');
  }

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  window.addEventListener('resize', resize);
  resize();

  const vertexSource = `
    attribute vec2 aPosition;
    void main() {
      gl_Position = vec4(aPosition, 0, 1);
    }
  `;

  const fragmentSource = `
    precision mediump float;
    uniform float iTime;
    uniform vec2 iResolution;

    float rand(vec2 co){
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }

    void mainImage(out vec4 fragColor, in vec2 fragCoord){
        vec2 uv = fragCoord / iResolution.xy;

        uv += vec2(iTime * 0.1, iTime * 0.1);

        float noise = rand(floor(uv * 20.0));

        vec3 color = vec3(
            0.5 + 0.5 * sin(iTime + uv.x * 10.0 + noise * 5.0),
            0.5 + 0.5 * sin(iTime + uv.y * 10.0 + noise * 5.0 + 2.0),
            0.5 + 0.5 * sin(iTime + (uv.x + uv.y) * 10.0 + noise * 5.0 + 4.0)
        );

        color = pow(color, vec3(1.5)); // brighten

        fragColor = vec4(color, 1.0);
    }

    void main() {
      mainImage(gl_FragColor, gl_FragCoord.xy);
    }
  `;

  function createShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  }

  function createProgram(vsSource, fsSource) {
    const vertexShader = createShader(gl.VERTEX_SHADER, vsSource);
    const fragmentShader = createShader(gl.FRAGMENT_SHADER, fsSource);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(program));
      return null;
    }
    return program;
  }

  const program = createProgram(vertexSource, fragmentSource);
  gl.useProgram(program);

  // Setup a full-screen triangle strip
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,
    1, -1,
    -1, 1,
    1, 1
  ]), gl.STATIC_DRAW);

  const positionLocation = gl.getAttribLocation(program, 'aPosition');
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  const iTimeLoc = gl.getUniformLocation(program, 'iTime');
  const iResLoc = gl.getUniformLocation(program, 'iResolution');

  let startTime = performance.now();

  function render() {
    resize();
    const currentTime = (performance.now() - startTime) / 1000;

    gl.uniform1f(iTimeLoc, currentTime);
    gl.uniform2f(iResLoc, canvas.width, canvas.height);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
  }

  render();
</script>
</body>
</html>
