<div class="content-box">
    <style>
        .sim-container {
            text-align: center;
            padding: 20px;
        }

        .sim-title {
            font-size: 18px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .instructions {
            font-size: 12px;
            margin-bottom: 15px;
            color: #666;
        }

        #neuralCanvas {
            border: 2px solid #000;
            background: #0a0a0a;
            cursor: crosshair;
            display: block;
            margin: 0 auto 20px auto;
        }

        .recordings-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .recording-plot {
            background: #1a1a1a;
            border: 2px solid #444;
            padding: 10px;
            width: 280px;
        }

        .recording-plot h4 {
            color: #fff;
            font-size: 11px;
            margin: 0 0 5px 0;
            text-align: center;
        }

        .recording-plot canvas {
            width: 100%;
            height: 120px;
            background: #000;
            border: 1px solid #666;
        }

        .recording-info {
            color: #aaa;
            font-size: 10px;
            margin-top: 5px;
            text-align: center;
        }

        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .controls button {
            padding: 8px 16px;
            background: #c0c0c0;
            border: 2px outset #888;
            cursor: pointer;
            font-family: "Courier New", monospace;
            font-weight: bold;
        }

        .controls button:active {
            border-style: inset;
        }

        .controls button.active {
            background: #ffff00;
        }

        .neuron-type {
            font-size: 11px;
            font-weight: bold;
        }

        .neuron-panel {
            position: absolute;
            background: #c0c0c0;
            border: 2px solid #000;
            padding: 10px;
            display: none;
            z-index: 1000;
            font-size: 12px;
            min-width: 200px;
        }

        .neuron-panel.visible {
            display: block;
        }

        .neuron-panel h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }

        .neuron-panel label {
            display: block;
            margin: 8px 0 4px 0;
            font-weight: bold;
        }

        .neuron-panel input[type="range"] {
            width: 100%;
        }

        .neuron-panel button {
            margin-top: 10px;
            padding: 5px 10px;
            background: #fff;
            border: 2px outset #888;
            cursor: pointer;
            width: 100%;
            font-family: "Courier New", monospace;
        }

        .neuron-panel button:active {
            border-style: inset;
        }

        .rate-value {
            display: inline-block;
            margin-left: 5px;
            color: #000;
        }
    </style>

    <div class="sim-container">
        <h2 class="sim-title">Neurons in a dish</h2>
        <p class="instructions">Click to place • Drag between neurons to connect • Click neuron to stimulate • Right-click to toggle type/properties</p>
        
        <canvas id="neuralCanvas" width="700" height="500"></canvas>
        
        <div class="recordings-container" id="recordingsContainer"></div>
        
        <div class="controls">
            <button id="clearBtn">Clear All</button>
            <button id="exciteBtn" class="active">Excitatory</button>
            <button id="inhibitBtn">Inhibitory</button>
        </div>

        <div id="neuronPanel" class="neuron-panel">
            <h3>Neuron Settings</h3>
            <label>
                Type: <span id="neuronTypeLabel">Excitatory</span>
            </label>
            <button id="toggleTypeBtn">Toggle Type</button>
            
            <label>
                Basal Firing Rate: <span class="rate-value" id="rateValue">0.00</span>
            </label>
            <input type="range" id="basalRateSlider" min="0" max="100" value="0" step="1">
            
            <label>
                Burst Frequency (Hz): <span class="rate-value" id="burstValue">0.00</span>
            </label>
            <input type="range" id="burstSlider" min="0" max="10" value="0" step="0.5">
            
            <label>
                Burst Duration (ms): <span class="rate-value" id="burstDurationValue">100</span>
            </label>
            <input type="range" id="burstDurationSlider" min="10" max="1000" value="100" step="10">
            
            <label style="margin-top: 10px;">
                <input type="checkbox" id="regularModeCheckbox"> Non-random Firing
            </label>
            
            <button id="closePanel">Close</button>
        </div>
    </div>

    <script>
        class Connection {
            constructor(from, to, type = 'excitatory') {
                this.from = from;
                this.to = to;
                this.type = type; // 'excitatory' or 'inhibitory'
                this.strength = type === 'excitatory' ? 0.6 : -0.4;
            }

            draw(ctx) {
                const alpha = Math.abs(this.from.activity) * 0.8 + 0.2;
                if (this.type === 'excitatory') {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                } else {
                    ctx.strokeStyle = `rgba(255, 100, 100, ${alpha})`;
                }
                ctx.lineWidth = 2;
                
                // Draw arrow
                const angle = Math.atan2(this.to.y - this.from.y, this.to.x - this.from.x);
                const endX = this.to.x - Math.cos(angle) * 15;
                const endY = this.to.y - Math.sin(angle) * 15;
                
                ctx.beginPath();
                ctx.moveTo(this.from.x, this.from.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Arrow head
                const headLen = 10;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), 
                          endY - headLen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), 
                          endY - headLen * Math.sin(angle + Math.PI / 6));
                ctx.stroke();
            }
        }

        class Neuron {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.activity = 0;
                this.basalRate = 0;
                this.threshold = 0.7;
                this.decayRate = 0.92;
                this.isExcitatory = true;
                this.id = Math.random().toString(36).substr(2, 9);
                this.spikeHistory = [];
                this.voltageTrace = new Array(400).fill(-70); // Resting potential
                this.lastSpikeTime = 0;
                this.timeSinceLastSpike = 0;
                this.regularMode = false; // False = random, True = regular firing
                this.inhibition = 0; // Accumulated inhibition
                this.burstFrequency = 0; // 0 = no bursting, 0-1 = burst frequency in Hz
                this.burstDuration = 100; // Duration of burst in ms
                this.timeSinceLastBurst = 0;
                this.inBurst = false;
            }

            update(dt = 16.67) { // dt in milliseconds (60 fps)
                const currentTime = Date.now();
                this.timeSinceLastSpike += dt;
                this.timeSinceLastBurst += dt;
                
                // Decay inhibition
                this.inhibition *= 0.9;
                
                // Handle bursting behavior
                if (this.burstFrequency > 0) {
                    const burstInterval = 1000 / this.burstFrequency; // ms between bursts
                    
                    if (this.inBurst) {
                        // Check if burst should end
                        if (this.timeSinceLastBurst >= this.burstDuration) {
                            this.inBurst = false;
                            this.timeSinceLastBurst = 0;
                        }
                    } else {
                        // Check if new burst should start
                        if (this.timeSinceLastBurst >= burstInterval) {
                            this.inBurst = true;
                            this.timeSinceLastBurst = 0;
                            this.timeSinceLastSpike = 0; // Reset for immediate spike in burst
                        }
                    }
                }
                
                // Calculate effective firing rate considering inhibition
                const basalHz = this.basalRate * 100; // 0-100 Hz range
                let effectiveHz = basalHz;
                
                // Apply inhibition as a multiplicative reduction
                if (this.inhibition > 0) {
                    effectiveHz = basalHz * (1 - Math.min(0.9, this.inhibition));
                }
                
                // Only fire if in burst (when bursting enabled) or always (when not bursting)
                const shouldFire = this.burstFrequency === 0 || this.inBurst;
                
                // Add basal firing
                if (effectiveHz > 0 && shouldFire) {
                    const interSpikeInterval = 1000 / effectiveHz; // ms between spikes
                    
                    if (this.regularMode) {
                        // Regular firing mode - fire at exact intervals
                        if (this.timeSinceLastSpike >= interSpikeInterval) {
                            this.activity = Math.min(1, this.activity + 0.8);
                            this.recordSpike(currentTime);
                            this.timeSinceLastSpike = 0;
                        }
                    } else {
                        // Random/Poisson firing mode
                        const probability = (effectiveHz * dt) / 1000;
                        if (Math.random() < probability) {
                            this.activity = Math.min(1, this.activity + 0.8);
                            this.recordSpike(currentTime);
                            this.timeSinceLastSpike = 0;
                        }
                    }
                }
                
                // Update voltage trace
                this.voltageTrace.shift();
                let voltage = -70; // Resting potential
                
                if (this.activity > 0.7) {
                    voltage = 40; // Action potential peak
                    this.lastSpikeTime = currentTime;
                } else if (this.activity > 0) {
                    voltage = -70 + (this.activity * 110); // Depolarization
                } else if (this.inhibition > 0) {
                    voltage = -70 - (this.inhibition * 15); // Hyperpolarization from inhibition
                }
                
                this.voltageTrace.push(voltage);
                
                this.activity *= this.decayRate;
                if (this.activity < 0.01) this.activity = 0;
            }

            recordSpike(time) {
                this.spikeHistory.push(time);
                // Keep only last 2 seconds of spikes
                const cutoff = time - 2000;
                this.spikeHistory = this.spikeHistory.filter(t => t > cutoff);
            }

            getFiringRate() {
                // Calculate firing rate from last 1 second
                const currentTime = Date.now();
                const recentSpikes = this.spikeHistory.filter(t => t > currentTime - 1000);
                return recentSpikes.length; // Spikes per second
            }

            applyInhibition(amount) {
                this.inhibition = Math.min(1, this.inhibition + Math.abs(amount));
            }

            stimulate(amount) {
                if (amount < 0) {
                    this.applyInhibition(amount);
                } else {
                    this.activity = Math.max(-1, Math.min(1, this.activity + amount));
                }
            }

            draw(ctx) {
                const radius = 12;
                
                // Color based on activity and type
                let color;
                if (this.activity > 0.1) {
                    const intensity = Math.abs(this.activity);
                    color = `rgba(255, 255, 100, ${intensity})`;
                } else if (this.activity < -0.1) {
                    const intensity = Math.abs(this.activity);
                    color = `rgba(100, 100, 255, ${intensity})`;
                } else {
                    color = this.isExcitatory ? 'rgba(100, 200, 255, 0.8)' : 'rgba(255, 100, 100, 0.8)';
                }

                // Draw neuron body
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw basal rate indicator
                if (this.basalRate > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw type indicator
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.isExcitatory ? '+' : '-', this.x, this.y);
            }
        }

        const canvas = document.getElementById('neuralCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        const neurons = [];
        const connections = [];
        let animationId;
        let connectionMode = 'excitatory';
        let isDragging = false;
        let dragStart = null;
        let dragEnd = null;
        let selectedNeuron = null;

        if (!canvas || !ctx) {
            console.error('Canvas not found');
        }

        function animate() {
            if (!ctx) return;
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and check for firing
            neurons.forEach(neuron => {
                neuron.update();
                if (Math.abs(neuron.activity) >= neuron.threshold) {
                    fire(neuron);
                }
            });

            // Draw connections
            connections.forEach(conn => conn.draw(ctx));

            // Draw neurons
            neurons.forEach(neuron => neuron.draw(ctx));

            // Draw drag line
            if (isDragging && dragStart && dragEnd) {
                ctx.strokeStyle = connectionMode === 'excitatory' ? 
                    'rgba(0, 255, 255, 0.5)' : 'rgba(255, 100, 100, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(dragStart.x, dragStart.y);
                ctx.lineTo(dragEnd.x, dragEnd.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            animationId = requestAnimationFrame(animate);
        }

        function updateRecordings() {
            const container = document.getElementById('recordingsContainer');
            container.innerHTML = '';
            
            neurons.forEach((neuron, idx) => {
                const plotDiv = document.createElement('div');
                plotDiv.className = 'recording-plot';
                
                const title = document.createElement('h4');
                title.textContent = `Neuron ${idx + 1} (${neuron.isExcitatory ? 'E' : 'I'})`;
                
                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 120;
                
                const info = document.createElement('div');
                info.className = 'recording-info';
                const firingRate = neuron.getFiringRate();
                const basalHz = Math.round(neuron.basalRate * 100);
                const mode = neuron.regularMode ? 'Non-random' : 'Poisson';
                const burstInfo = neuron.burstFrequency > 0 ? ` | Burst: ${neuron.burstFrequency.toFixed(1)} Hz` : '';
                info.textContent = `${firingRate} Hz (${mode}, basal: ${basalHz} Hz${burstInfo})`;
                
                plotDiv.appendChild(title);
                plotDiv.appendChild(canvas);
                plotDiv.appendChild(info);
                container.appendChild(plotDiv);
                
                // Draw voltage trace
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                neuron.voltageTrace.forEach((v, i) => {
                    const x = i;
                    const y = canvas.height - ((v + 80) / 130) * canvas.height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                
                ctx.stroke();
                
                // Draw reference lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 0.5;
                
                // 0 mV line
                const zeroY = canvas.height - ((0 + 80) / 130) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, zeroY);
                ctx.lineTo(canvas.width, zeroY);
                ctx.stroke();
                
                // -70 mV line (resting)
                const restY = canvas.height - ((-70 + 80) / 130) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, restY);
                ctx.lineTo(canvas.width, restY);
                ctx.stroke();
            });
        }

        // Update recordings every 100ms
        setInterval(updateRecordings, 100);

        function fire(neuron) {
            const outgoing = connections.filter(c => c.from === neuron);
            outgoing.forEach(conn => {
                setTimeout(() => {
                    conn.to.stimulate(conn.strength);
                }, Math.random() * 30 + 10);
            });
            neuron.activity *= 0.5; // Reset after firing
        }

        function getNeuronAt(x, y) {
            return neurons.find(n => {
                const dist = Math.hypot(n.x - x, n.y - y);
                return dist < 15;
            });
        }

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const neuron = getNeuronAt(x, y);
            
            if (neuron) {
                isDragging = true;
                dragStart = neuron;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                dragEnd = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const targetNeuron = getNeuronAt(x, y);
                
                if (targetNeuron && targetNeuron !== dragStart) {
                    // Create connection
                    const existing = connections.find(c => c.from === dragStart && c.to === targetNeuron);
                    if (!existing) {
                        connections.push(new Connection(dragStart, targetNeuron, connectionMode));
                    }
                }
                
                isDragging = false;
                dragStart = null;
                dragEnd = null;
            }
        });

        canvas.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const neuron = getNeuronAt(x, y);
            
            if (neuron) {
                // Stimulate neuron
                neuron.stimulate(0.8);
            } else {
                // Place new neuron
                const newNeuron = new Neuron(x, y);
                newNeuron.isExcitatory = (connectionMode === 'excitatory');
                neurons.push(newNeuron);
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const neuron = getNeuronAt(x, y);
            if (neuron) {
                // Show settings panel
                selectedNeuron = neuron;
                const panel = document.getElementById('neuronPanel');
                panel.style.left = (e.clientX + 10) + 'px';
                panel.style.top = (e.clientY + 10) + 'px';
                panel.classList.add('visible');
                
                // Update panel values
                document.getElementById('neuronTypeLabel').textContent = 
                    neuron.isExcitatory ? 'Excitatory' : 'Inhibitory';
                document.getElementById('basalRateSlider').value = Math.round(neuron.basalRate * 100);
                document.getElementById('rateValue').textContent = neuron.basalRate.toFixed(2);
                document.getElementById('burstSlider').value = neuron.burstFrequency;
                document.getElementById('burstValue').textContent = neuron.burstFrequency.toFixed(2);
                document.getElementById('burstDurationSlider').value = neuron.burstDuration;
                document.getElementById('burstDurationValue').textContent = neuron.burstDuration;
                document.getElementById('regularModeCheckbox').checked = neuron.regularMode;
            }
        });

        canvas.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const neuron = getNeuronAt(x, y);
            if (neuron) {
                // Toggle excitatory/inhibitory
                neuron.isExcitatory = !neuron.isExcitatory;
            }
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            neurons.length = 0;
            connections.length = 0;
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            document.getElementById('neuronPanel').classList.remove('visible');
        });

        document.getElementById('exciteBtn').addEventListener('click', () => {
            connectionMode = 'excitatory';
            document.querySelectorAll('.controls button').forEach(btn => btn.classList.remove('active'));
            document.getElementById('exciteBtn').classList.add('active');
        });

        document.getElementById('inhibitBtn').addEventListener('click', () => {
            connectionMode = 'inhibitory';
            document.querySelectorAll('.controls button').forEach(btn => btn.classList.remove('active'));
            document.getElementById('inhibitBtn').classList.add('active');
        });

        document.getElementById('toggleTypeBtn').addEventListener('click', () => {
            if (selectedNeuron) {
                selectedNeuron.isExcitatory = !selectedNeuron.isExcitatory;
                document.getElementById('neuronTypeLabel').textContent = 
                    selectedNeuron.isExcitatory ? 'Excitatory' : 'Inhibitory';
            }
        });

        document.getElementById('basalRateSlider').addEventListener('input', (e) => {
            if (selectedNeuron) {
                selectedNeuron.basalRate = parseInt(e.target.value) / 100;
                document.getElementById('rateValue').textContent = selectedNeuron.basalRate.toFixed(2);
            }
        });

        document.getElementById('burstSlider').addEventListener('input', (e) => {
            if (selectedNeuron) {
                selectedNeuron.burstFrequency = parseFloat(e.target.value);
                document.getElementById('burstValue').textContent = selectedNeuron.burstFrequency.toFixed(2);
                selectedNeuron.timeSinceLastBurst = 0;
                selectedNeuron.inBurst = false;
            }
        });

        document.getElementById('burstDurationSlider').addEventListener('input', (e) => {
            if (selectedNeuron) {
                selectedNeuron.burstDuration = parseInt(e.target.value);
                document.getElementById('burstDurationValue').textContent = selectedNeuron.burstDuration;
            }
        });

        document.getElementById('regularModeCheckbox').addEventListener('change', (e) => {
            if (selectedNeuron) {
                selectedNeuron.regularMode = e.target.checked;
                selectedNeuron.timeSinceLastSpike = 0; // Reset timing
            }
        });

        document.getElementById('closePanel').addEventListener('click', () => {
            document.getElementById('neuronPanel').classList.remove('visible');
            selectedNeuron = null;
        });

        // Close panel when clicking outside
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('neuronPanel');
            if (!panel.contains(e.target) && e.target !== canvas) {
                panel.classList.remove('visible');
                selectedNeuron = null;
            }
        });

        // Initialize
        if (canvas && ctx) {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            animate();
        }
    </script>
</div>
